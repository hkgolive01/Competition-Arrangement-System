<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <title></title>
  <style>
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      margin: 20px;
      background: #ffffff;
      color: #333;
    }

    input,
    button,
    textarea,
    select {
      padding: 2px;
      margin: 0px;
      font-size: 18px;
    }

    button {
      padding: 8px 16px;
      border-radius: 8px;
      border: 1px solid #fa8c8c;
      background: linear-gradient(#ffffff, #ffffff);
      color: #24292f;
      font-weight: 500;
      transition: all 0.2s ease;
      cursor: pointer;
    }

    button:hover {
      background: linear-gradient(#ffffff, #ffffff);
      border-color: #190101;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    button:active {
      background: #ffffff;
      transform: translateY(1px);
    }

    button.selected-round,
    button.active {
      background: linear-gradient(#f39147, #f0f40d);
      color: #24292f;
    }

    .player-markers {
      margin-top: 5px;
    }

    button.pairing-mode-btn {
      padding: 8px 16px;
      border-radius: 8px;
      background: linear-gradient(#ffffff, #ffffff);
      color: #24292f;
      transition: all 0.2s ease;
    }

    button.pairing-mode-btn.selected-mode {
      background: linear-gradient(#f39147, #f0f40d);
      color: #24292f;
    }

    button.pairing-mode-btn:disabled {
      cursor: not-allowed;
    }

    .round-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;
    }

    .round-controls .left-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .round-controls .right-group {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    #stateControl {
      display: flex;
      gap: 12px;
      padding: 12px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #e0e4e9;
      align-items: center;
    }

    #roundNav {
      display: flex;
      gap: 8px;
      padding: 12px;
      border-radius: 8px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    #roundNav button {
      min-width: 80px;
      padding: 8px 12px;
    }

    .match-player strong.player-name {
      cursor: pointer;
      transition: all 0.3s;
    }

    .match-player strong.player-name.selected {
      background-color: #ffeb3b !important;
      outline: 2px solid #ff9a0c;
      border-radius: 4px;
      padding: 2px 5px;
    }

    .section {
      margin-bottom: 20px;
      background: #fff;
      padding-top: 5px;
      padding-left: 10px;
      padding-right: 10px;
      padding-bottom: 10px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      border: 2px solid #ff990a;
    }

    .competition-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
    }

    .header-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .header-left,
    .header-right {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .header-tools {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      padding-top: 6px;
      border-top: 1px dashed rgba(0, 0, 0, 0.04);
    }

    .tools-left,
    .tools-right {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    @media (max-width: 1400px) {

      .header-top,
      .header-tools {
        flex-direction: column;
        align-items: flex-start;
      }

      .header-right,
      .tools-right {
        width: 100%;
        justify-content: flex-start;
      }
    }

    .competition-info label {
      white-space: nowrap;
    }

    .container {
      display: flex;
    }

    .left {
      flex: 1;
      min-width: 500px;
    }

    .right {
      width: 400px;
      margin-left: 20px;
    }

    #matchTable {
      width: 100%;
      font-size: 130%;
      table-layout: auto;
      margin-bottom: 10px;
    }

    th {
      background-color: #ff920c;
    }

    #matchTable th,
    #matchTable td {
      border: 1px solid #f8f5af;
      padding: 6px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      line-height: 1;
    }

    #matchTable th:nth-child(1),
    #matchTable td:nth-child(1) {
      width: 15%;
      white-space: nowrap;
    }

    .match-row {
      display: grid;
      width: 100%;
      grid-template-columns: 36% 28% 36%;
      align-items: center;
      column-gap: 0px;
    }

    .match-player,
    .match-result {
      text-align: center;
      justify-self: center;
    }

    #scoreboard {
      width: 100% !important;
      table-layout: fixed;
      border-collapse: collapse;
    }

    #scoreboard th,
    #scoreboard td {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 1px solid #ffffff;
      padding: 4px !important;
      text-align: center;
      vertical-align: middle;
      line-height: 0.9 !important;
    }

    #scoreboard tbody tr:not(.history-row) {
      height: 24px !important;
    }

    #scoreboard tbody tr:not(.history-row) td {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .history-row td {
      background-color: transparent !important;
      padding: 0 !important;
      line-height: 1 !important;
      vertical-align: top !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
    }

    .history-box {
      display: inline-block;
      position: relative;
      top: -4px;
      font-size: 12px !important;
      line-height: 1 !important;
      padding: 3px 4px;
      border: 1px solid #f1c40f;
      border-radius: 6px;
      background: transparent;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .history-label {
      font-style: normal;
      font-weight: bold;
    }

    #scoreboard th:not(:last-child),
    #scoreboard td:not(:last-child) {
      width: auto !important;
    }

    #scoreboard tbody tr:nth-child(-n+16) td:nth-child(1),
    #scoreboard tbody tr:nth-child(-n+16) td:nth-child(2) {
      background-color: #fffd95;
    }

    #scoreboard tbody td:nth-child(4) {
      background-color: #ffed95;
    }

    #scoreboard tbody td:nth-child(5) {
      background-color: #fffed1d6;
    }

    #scoreboard tbody td:nth-child(7) {
      background-color: #fffeda9d;
    }

    #scoreboard tbody td:nth-child(2) {
      font-size: 24px !important;
    }

    #scoreboard tbody td:nth-child(1),
    #scoreboard tbody td:nth-child(4) {
      font-size: 1.5em;
    }

    #scoreboard tbody td:nth-child(3) {
      font-size: 1em;
    }

    #scoreboard tbody td:nth-child(6),
    #scoreboard tbody td:nth-child(8),
    #scoreboard tbody td:nth-child(9) {
      font-size: 0.7em;
    }

    #scoreboard tbody td:nth-child(5) {
      font-size: 1.2em;
    }

    #scoreboard tbody td:nth-child(7) {
      font-size: 0.9em;
    }

    #scoreboard tbody tr,
    #scoreboard tbody tr.history-row {
      height: 18px !important;
    }

    .marker-span {
      display: block;
      padding: 2px 6px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 0.9em;
    }

    .marker-female {
      background-color: #fae1e1;
    }

    .marker-isFinalist {
      background-color: #d7bff6;
    }

    .marker-cancel {
      background-color: #25f01e;
    }

    .marker-reward {
      background-color: #fff59d;
    }

    .result-btn {
      border: 1px solid #ffffff;
      color: #333;
      margin: 0 2px;
      padding: 4px 8px;
      font-size: 100%;
    }

    .result-btn.selected {
      background-color: #90ee90;
      color: #000;
      font-size: 160%;
      border: none;
    }

    .result-btn.special-light {
      background-color: rgba(224, 247, 250, 0.005);
      color: rgba(0, 121, 107, 0.005);
      border: 1px solid rgba(204, 204, 204, 0.005);
      font-size: 100%;
    }

    .result-btn.special-light.selected {
      background-color: rgba(144, 238, 144, 0.005);
      color: #27007c;
      border: 1px solid rgba(144, 238, 144, 0.2);
      font-size: 100%;
    }

    td.opponent-history {
      white-space: nowrap !important;
      display: flex;
      flex-wrap: nowrap;
      gap: 2px;
      overflow-x: auto;
    }

    td.opponent-history div {
      flex: 1;
      text-align: center;
      padding: 5px 10px;
      background: #ffffff;
      border-radius: 3px;
      min-width: 128px;
    }

    @media print {
      body {
        margin: 0;
        padding: 0;
      }

      html {
        margin: 0;
        padding: 0;
      }

      .section {
        background: transparent !important;
        box-shadow: none !important;
        border: none !important;
        border-radius: 0 !important;
        padding-top: 0 !important;
        padding-bottom: 0 !important;
      }

      .print-group-info {
        margin-top: 0 !important;
      }

      .print-group-info h1 {
        margin-top: 0 !important;
      }
    }

    #roundSelection button {
      padding: 4px 8px;
      margin: 0 2px;
    }

    #roundNav button {
      margin-right: 5px;
      padding: 4px 8px;
    }

    #roundTitle,
    #scoreboardTitle {
      font-size: 18px;
    }

    .player-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    #clearNumbersBtn {
      background: #ff6666;
      border: none;
      color: #fff;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
    }

    #clearNumbersBtn:hover {
      background: #ff4d4d;
    }

    .print-player-number {
      font-size: 0.7em;
    }

    .print-player-name {
      font-size: 1.3em;
    }

    #lockedRound {
      padding: 6px 12px;
      border-radius: 8px;
      background: #f0f0f0;
    }

    button.round-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      border: 1px solid #fa8c8c;
    }

    button.round-btn:disabled.selected-round {
      background: linear-gradient(#f39147, #f0f40d);
      color: #24292f;
      opacity: 1;
    }

    .state-checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 8px;
      white-space: nowrap;
    }

    body.layout-split .container {
      flex-direction: row;
      gap: 20px;
    }

    body.layout-split .left,
    body.layout-split .right {
      width: 50%;
      flex: 0 0 50%;
      min-width: 0;
    }

    body.layout-split .right {
      margin-left: 0;
    }

    body.layout-split-with-players .container {
      flex-direction: row;
      gap: 20px;
    }

    body.layout-split-with-players .left,
    body.layout-split-with-players .right {
      width: calc((100% - var(--players-width, 0px)) / 2);
      flex: 0 0 calc((100% - var(--players-width, 0px)) / 2);
      min-width: 0;
    }

    body.layout-split-with-players .right {
      margin-left: 0;
    }

    body.layout-split #roundContainer,
    body.layout-split #scoreboard,
    body.layout-split-with-players #roundContainer,
    body.layout-split-with-players #scoreboard {
      overflow: auto;
    }

    #playersSection {
      position: fixed;
      left: 20px;
      bottom: 20px;
      width: 800px;
      height: 50%;
      z-index: 11000;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      background: #fff;
      border-radius: 8px;
      overflow: auto;
      display: none;
      padding: 12px;
      border: 1px solid #e0e4e9;
    }

    #playersSection.open {
      display: block;
    }

    @media print {
      #playersSection {
        display: none !important;
      }
    }

    .competition-info {
      position: sticky;
      top: 0;
      z-index: 9999;
      background: #ffffff;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
      padding: 12px;
    }

    .competition-info #roundNav {
      display: flex;
      gap: 8px;
      padding-top: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin: 0;
    }

    body.layout-split-huge .left {
      width: 40%;
      flex: 0 0 40%;
    }

    body.layout-split-huge .right {
      width: 60%;
      flex: 0 0 60%;
    }

    .competition-info * {
      z-index: 10000;
    }

    .container {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      width: 100%;
      box-sizing: border-box;
    }

    .left,
    .middle,
    .right {
      flex: 1 1 20% !important;
      min-width: 20% !important;
      box-sizing: border-box !important;
    }

    .right {
      width: auto !important;
      margin-left: 0 !important;
    }

    #playersList {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    #playersList li {
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 3px;
      box-sizing: border-box;
      box-shadow: 0 1px 2px rgb(240, 103, 103);
    }

    #playersList li .player-details {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1 1 auto;
      min-width: 0;
      flex-wrap: nowrap;
      overflow: hidden;
    }

    #playersList li .player-number-lock {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #playersList li .player-name {
      flex: 0 1 auto;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
    }

    #playersList li .player-markers {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    #playersList li .player-markers .marker-btn,
    #playersList li .player-markers select {
      padding: 4px 6px;
      font-size: 12px;
      height: auto;
      width: auto;
      min-width: 0;
    }

    #playersList li .player-actions {
      flex: 0 0 auto;
      margin-left: 8px;
      white-space: nowrap;
    }

    #playersList li .player-details-grid {
      display: flex;
      gap: 8px;
      width: 100%;
      align-items: center;
    }

    #playersList li .player-details-grid .col {
      flex: 1 1 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      min-width: 0;
    }

    #playersList li .player-details-grid .col .label {
      font-size: 0.8em;
      color: #666;
      margin-bottom: 4px;
    }

    #playersList li .player-details-grid input[type="text"] {
      width: 60%;
      text-align: center;
      padding: 4px;
      box-sizing: border-box;
    }

    #playersList li .player-details-grid select {
      width: 80%;
      padding: 4px;
      box-sizing: border-box;
    }

    @media (max-width: 1400px) {
      .container {
        flex-direction: column;
      }

      .left,
      .middle,
      .right {
        width: 100% !important;
        flex: 0 0 auto !important;
      }
    }

    body.layout-three-column .left {
      width: 35% !important;
      flex: 0 0 35% !important;
      box-sizing: border-box;
    }

    body.layout-three-column .middle {
      width: 35% !important;
      flex: 0 0 35% !important;
      box-sizing: border-box;
    }

    body.layout-three-column .right {
      width: 30% !important;
      flex: 0 0 30% !important;
      box-sizing: border-box;
    }

    .left,
    .middle,
    .right {
      min-width: 0;
      box-sizing: border-box;
    }

    .marker-btn {
      background: #fff8c2;
      border: 1px solid #ffec9a;
      color: #222;
      padding: 2px 3px;
      font-size: 0.85em;
      min-width: 28px;
      height: 30px;
      border-radius: 3px;
      cursor: pointer;
    }

    .marker-btn.selected-marker {
      background: #ffd166;
      border-color: #ffb84d;
      color: #fff;
    }

    .player-action-btn {
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #e05a5a;
      background: #ff6666;
      color: #fff;
      cursor: pointer;
      font-size: 0.85em;
      min-width: 60px;
    }

    #matchTable thead th {
      border: none !important;
    }

    :root {
      --uniform-table-font-size: 16px;
      --uniform-table-line-height: 1.1;
    }

    #matchTable,
    #matchTable th,
    #scoreboard,
    #scoreboard th,
    #roundContainer,
    #roundTitle,
    #scoreboardTitle,
    .match-row,
    .match-player,
    .match-result {
      font-size: var(--uniform-table-font-size) !important;
      line-height: var(--uniform-table-line-height) !important;
    }

    :root {
      --col1: 5%;
      --col2: 14%;
      --col3: 11.5%;
      --col4: 6%;
      --col5: 8%;
      --col6: 15%;
      --col7: 8%;
      --col8: 14%;
      --col9: 18.5%;
    }

    #scoreboard {
      width: 100% !important;
      table-layout: fixed !important;
      max-width: 100%;
    }

    #scoreboard th:nth-child(1),
    #scoreboard td:nth-child(1) {
      width: var(--col1) !important;
    }

    #scoreboard th:nth-child(2),
    #scoreboard td:nth-child(2) {
      width: var(--col2) !important;
    }

    #scoreboard th:nth-child(3),
    #scoreboard td:nth-child(3) {
      width: var(--col3) !important;
    }

    #scoreboard th:nth-child(4),
    #scoreboard td:nth-child(4) {
      width: var(--col4) !important;
    }

    #scoreboard th:nth-child(5),
    #scoreboard td:nth-child(5) {
      width: var(--col5) !important;
    }

    #scoreboard th:nth-child(6),
    #scoreboard td:nth-child(6) {
      width: var(--col6) !important;
    }

    #scoreboard th:nth-child(7),
    #scoreboard td:nth-child(7) {
      width: var(--col7) !important;
    }

    #scoreboard th:nth-child(8),
    #scoreboard td:nth-child(8) {
      width: var(--col8) !important;
    }

    #scoreboard th:nth-child(9),
    #scoreboard td:nth-child(9) {
      width: var(--col9) !important;
    }

    @media (max-width: 760px) {
      #playersList li .player-details-grid {
        flex-direction: column;
        gap: 6px;
      }

      #playersList li .player-details-grid .col {
        width: 100%;
      }
    }
  </style>
  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;700&display=swap" rel="stylesheet">
  <style>
    body {
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
      font-family: 'Noto Sans TC', -apple-system, 'Segoe UI', Roboto, Arial, sans-serif;
    }
  </style>

  <style>
    .small-latin {
      display: inline-block;
      font-size: 0.72em !important;
      line-height: 1 !important;
      vertical-align: baseline !important;
      white-space: pre-wrap;
    }

    #scoreboard td:nth-child(2) .small-latin {
      font-size: 0.72em !important;
      line-height: 1 !important;
    }

    #roundSection .small-latin,
    #pairingsSection .small-latin,
    #pairingsTable .small-latin {
      font-size: 0.72em !important;
      line-height: 1 !important;
      vertical-align: baseline !important;
      display: inline-block;
      white-space: pre-wrap;
    }

    [data-suppress-pairings-flash="1"] {
      visibility: hidden;
    }

    @media print {
      .small-latin {
        font-size: 0.5em;
      }
    }

    #cas_time_picker_modal {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 2147483650;
      background: #fff;
      border: 1px solid rgba(0, 0, 0, 0.08);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      min-width: 230px;
      font-size: 14px;
      font-family: sans-serif;
    }

    #cas_time_picker_modal input[type="number"] {
      padding: 6px;
      width: 68px;
      box-sizing: border-box;
    }

    #cas_time_picker_modal button {
      padding: 6px 10px;
      cursor: pointer;
      margin-left: 4px;
    }
  </style>

  <script>
    (function () {
      function addMinutesAndRoundUp(dateISOorDate, addMinutes) {
        if (!dateISOorDate) return null;
        const d = (typeof dateISOorDate === 'string') ? new Date(dateISOorDate) : new Date(dateISOorDate);
        if (!(d instanceof Date) || isNaN(d)) return null;
        d.setMinutes(d.getMinutes() + (Number(addMinutes) || 0));
        if (d.getSeconds() > 0 || d.getMilliseconds() > 0) {
          d.setSeconds(0);
          d.setMilliseconds(0);
          d.setMinutes(d.getMinutes() + 1);
        } else {
          d.setSeconds(0);
          d.setMilliseconds(0);
        }
        return d;
      }

      function formatTime(dateOrISO) {
        if (!dateOrISO) return '';
        const d = (typeof dateOrISO === 'string') ? new Date(dateOrISO) : new Date(dateOrISO);
        if (!(d instanceof Date) || isNaN(d)) return '';
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return hh + ':' + mm;
      }

      function computePredictedStartTimeForRound(rn) {
        try {
          const playersCount = (typeof players !== 'undefined' && Array.isArray(players))
            ? players.filter(p => !p.withdrawn).length : 0;
          let extra = 0;
          if (playersCount >= 24) extra++;
          if (playersCount >= 32) extra++;
          if (playersCount >= 40) extra++;
          const roundObj = (typeof rounds !== 'undefined' && Array.isArray(rounds) && rounds.length >= rn)
            ? rounds[rn - 1] : null;
          const arrangedISO = (roundObj && roundObj.arrangedAt) ? roundObj.arrangedAt : null;
          const base = arrangedISO ? arrangedISO : new Date().toISOString();
          return addMinutesAndRoundUp(base, 3 + extra);
        } catch (e) {
          return addMinutesAndRoundUp(new Date().toISOString(), 3);
        }
      }

      function showTimePickerModal(defaultDate) {
        return new Promise((resolve) => {
          const existing = document.getElementById('cas_time_picker_modal');
          if (existing) existing.remove();

          const modal = document.createElement('div');
          modal.id = 'cas_time_picker_modal';

          const title = document.createElement('div');
          title.textContent = '自定開賽時間';
          title.style.fontWeight = '700';
          title.style.marginBottom = '8px';
          modal.appendChild(title);

          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.gap = '8px';
          row.style.alignItems = 'center';

          const hour = document.createElement('input');
          hour.type = 'number'; hour.min = 0; hour.max = 23;
          hour.value = defaultDate ? new Date(defaultDate).getHours() : new Date().getHours();

          const minute = document.createElement('input');
          minute.type = 'number'; minute.min = 0; minute.max = 59;
          minute.value = defaultDate ? new Date(defaultDate).getMinutes() : new Date().getMinutes();

          const hint = document.createElement('div');
          hint.textContent = '(24 小時)';
          hint.style.fontSize = '12px';
          hint.style.color = '#666';

          row.appendChild(hour); row.appendChild(minute); row.appendChild(hint);
          modal.appendChild(row);

          const btnRow = document.createElement('div');
          btnRow.style.display = 'flex';
          btnRow.style.justifyContent = 'flex-end';
          btnRow.style.gap = '6px';
          btnRow.style.marginTop = '10px';

          const btnShot = document.createElement('button');
          btnShot.textContent = '截圖對陣表';
          btnShot.onclick = () => {
            const base = defaultDate ? new Date(defaultDate) : new Date();
            const hh = Math.max(0, Math.min(23, parseInt(hour.value || '0', 10)));
            const mm = Math.max(0, Math.min(59, parseInt(minute.value || '0', 10)));
            base.setHours(hh, mm, 0, 0);
            cleanup();
            resolve(base);
          };

          const btnCancel = document.createElement('button');
          btnCancel.textContent = '取消截圖';
          btnCancel.onclick = () => { cleanup(); resolve(null); };

          btnRow.appendChild(btnShot); btnRow.appendChild(btnCancel);
          modal.appendChild(btnRow);

          function cleanup() {
            if (modal && modal.parentNode) modal.parentNode.removeChild(modal);
          }

          document.body.appendChild(modal);
          hour.focus();
        });
      }

      async function unifiedScreenshotElementToClipboard(element, options = {}) {
        if (!element) throw new Error('element is required');
        options = options || {};
        const clone = element.cloneNode(true);
        const wrapper = document.createElement('div');
        wrapper.style.position = 'relative';
        wrapper.style.display = 'inline-block';
        wrapper.style.background = window.getComputedStyle(element).background || '#fff';
        wrapper.appendChild(clone);

        const topRightBox = document.createElement('div');
        topRightBox.style.position = 'absolute';
        topRightBox.style.right = '8px';
        topRightBox.style.top = '8px';
        topRightBox.style.background = 'rgba(255,255,255,0.95)';
        topRightBox.style.padding = '8px';
        topRightBox.style.borderRadius = '6px';
        topRightBox.style.boxShadow = '0 4px 10px rgba(0,0,0,0.08)';
        topRightBox.style.zIndex = '9999';
        topRightBox.style.fontFamily = 'sans-serif';
        topRightBox.style.color = '#111';
        topRightBox.style.maxWidth = '320px';
        topRightBox.style.fontSize = '12px';

        try {
          const rn = (typeof viewRound !== 'undefined' && viewRound) ? viewRound
            : ((typeof currentRound !== 'undefined' && currentRound) ? currentRound : 1);
          const roundObj = (typeof rounds !== 'undefined' && Array.isArray(rounds) && rounds[rn - 1]) ? rounds[rn - 1] : null;
          const arrangedISO = (roundObj && roundObj.arrangedAt) ? roundObj.arrangedAt : null;
          const playersCount = (typeof players !== 'undefined' && Array.isArray(players)) ? players.filter(p => !p.withdrawn).length : 0;
          let extra = 0;
          if (playersCount >= 24) extra++;
          if (playersCount >= 32) extra++;
          if (playersCount >= 40) extra++;

          const override = (options && options.overrideStartDate) ? (options.overrideStartDate instanceof Date ? options.overrideStartDate : new Date(options.overrideStartDate)) : null;
          const startDate = override ? override : (arrangedISO ? addMinutesAndRoundUp(arrangedISO, 3 + extra) : addMinutesAndRoundUp(new Date().toISOString(), 3 + extra));
          const startDisplay = startDate ? formatTime(startDate) : '';

          const line1 = document.createElement('div');
          line1.textContent = '第' + rn + '輪賽事 對陣表編排時間: ' + (arrangedISO ? formatTime(arrangedISO) : formatTime(new Date()));
          line1.style.fontSize = '14px';
          line1.style.fontWeight = '700';
          topRightBox.appendChild(line1);

          const spacer = document.createElement('div');
          spacer.style.height = '6px';
          topRightBox.appendChild(spacer);

          const line2 = document.createElement('div');
          const labelPrefix = override ? '第' + rn + '輪賽事 開賽時間: ' : '第' + rn + '輪賽事 預計開賽時間: ';
          line2.textContent = labelPrefix + startDisplay;
          line2.style.fontSize = '17px';
          line2.style.fontWeight = '700';
          line2.style.background = '#FDFD0D';
          topRightBox.appendChild(line2);
        } catch (e) {
          console.warn('build topRightBox failed', e);
        }

        wrapper.appendChild(topRightBox);
        wrapper.style.position = 'fixed';
        wrapper.style.left = '-99999px';
        wrapper.style.top = '-99999px';
        document.body.appendChild(wrapper);

        const rect = element.getBoundingClientRect();
        const width = Math.ceil(rect.width) || wrapper.offsetWidth || 800;
        const height = Math.ceil(rect.height) || wrapper.offsetHeight || 600;
        const dpr = window.devicePixelRatio || 1;

        async function domElementToCanvas(el, w, h, scale) {
          if (typeof html2canvas !== 'undefined') {
            return await html2canvas(el, { backgroundColor: null, scale: scale });
          }
          const cloned = el.cloneNode(true);
          try {
            const computed = window.getComputedStyle(el);
            cloned.style.width = w + 'px';
            cloned.style.height = h + 'px';
            cloned.style.boxSizing = 'border-box';
            cloned.style.background = computed.background || cloned.style.background;
          } catch (e) { }
          const serialized = new XMLSerializer().serializeToString(cloned);
          const svgString = '<svg xmlns="http://www.w3.org/2000/svg" width="' + w + '" height="' + h + '"><foreignObject width="100%" height="100%">' + serialized + '</foreignObject></svg>';
          const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
          try {
            const img = await createImageBitmap(svgBlob);
            const canvas = document.createElement('canvas');
            canvas.width = Math.round(w * scale);
            canvas.height = Math.round(h * scale);
            const ctx = canvas.getContext('2d');
            ctx.setTransform(scale, 0, 0, scale, 0, 0);
            ctx.drawImage(img, 0, 0, w, h);
            return canvas;
          } catch (err) {
            return new Promise((resolve, reject) => {
              const url = URL.createObjectURL(svgBlob);
              const imgEl = new Image();
              imgEl.onload = function () {
                const canvas = document.createElement('canvas');
                canvas.width = Math.round(w * scale);
                canvas.height = Math.round(h * scale);
                const ctx = canvas.getContext('2d');
                ctx.setTransform(scale, 0, 0, scale, 0, 0);
                ctx.drawImage(imgEl, 0, 0);
                URL.revokeObjectURL(url);
                resolve(canvas);
              };
              imgEl.onerror = function (e) { URL.revokeObjectURL(url); reject(e); };
              imgEl.src = url;
            });
          }
        }

        try {
          const canvas = await domElementToCanvas(wrapper, width, height, dpr);
          const blob = await new Promise((res) => canvas.toBlob(res, 'image/png'));
          if (!blob) throw new Error('toBlob failed');

          if (navigator.clipboard && navigator.clipboard.write) {
            try {
              const item = new ClipboardItem({ 'image/png': blob });
              await navigator.clipboard.write([item]);
              if (wrapper && wrapper.parentNode) wrapper.parentNode.removeChild(wrapper);
              return;
            } catch (err) {
              console.warn('clipboard write failed, fallback to download', err);
            }
          }

          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'pairings_' + Date.now() + '.png';
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        } catch (err) {
          console.error('screenshot error', err);
          alert('截圖失敗:' + (err && err.message ? err.message : '未知錯誤'));
        } finally {
          try { if (wrapper && wrapper.parentNode) wrapper.parentNode.removeChild(wrapper); } catch (e) { }
        }
      }

      window.screenshotElementToClipboard = unifiedScreenshotElementToClipboard;
      window.computePredictedStartTimeForRound = computePredictedStartTimeForRound;

      function wrapLatinDigitsInTextNode(textNode) {
        const txt = textNode.nodeValue;
        if (!txt || !/[A-Za-z0-9]/.test(txt)) return;
        const replacedHTML = txt.replace(/([A-Za-z0-9]+)/g, '<span class="small-latin">$1</span>');
        if (replacedHTML === txt) return;
        const frag = document.createRange().createContextualFragment(replacedHTML);
        const parent = textNode.parentNode;
        if (!parent) return;
        parent.replaceChild(frag, textNode);
      }
      function processElementTextNodes(el) {
        if (!el) return;
        const skipTags = ['INPUT', 'TEXTAREA', 'SELECT'];
        if (skipTags.includes(el.tagName)) return;
        if (el.isContentEditable) return;
        const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
          acceptNode: function (node) {
            if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
            let p = node.parentNode;
            while (p && p !== document.body) {
              if (p.classList && p.classList.contains('small-latin')) return NodeFilter.FILTER_REJECT;
              if (p.tagName === 'SCRIPT' || p.tagName === 'STYLE') return NodeFilter.FILTER_REJECT;
              p = p.parentNode;
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        }, false);
        const nodes = [];
        let cur;
        while (cur = walker.nextNode()) nodes.push(cur);
        nodes.forEach(n => { try { wrapLatinDigitsInTextNode(n); } catch (e) { } });
      }

      function findResultsTables() {
        const tables = Array.from(document.querySelectorAll('table'));
        const results = [];
        const tableClassRegex = /(result|results|ranking|score|scores|成績|排行榜)/i;
        tables.forEach(table => {
          try {
            const caption = table.querySelector('caption');
            if (caption && caption.textContent && caption.textContent.trim().includes('成績總表')) { results.push(table); return; }
            if (table.className && tableClassRegex.test(table.className)) { results.push(table); return; }
            if (table.id && tableClassRegex.test(table.id)) { results.push(table); return; }
            let prev = table.previousElementSibling;
            let steps = 0, found = false;
            while (prev && steps < 6) {
              if (/^H[1-4]$/i.test(prev.tagName) && prev.textContent && prev.textContent.trim().includes('成績總表')) { found = true; break; }
              if ((prev.tagName === 'DIV' || prev.tagName === 'SECTION' || prev.tagName === 'ARTICLE') && prev.textContent && prev.textContent.includes('成績總表')) { found = true; break; }
              prev = prev.previousElementSibling; steps++;
            }
            if (found) { results.push(table); return; }
            const anc = table.closest('section, article, main, .panel, .card, .container, .results-container') || table.parentElement;
            if (anc) {
              const headingInside = anc.querySelector('h1,h2,h3,h4,caption');
              if (headingInside && headingInside.textContent && headingInside.textContent.includes('成績總表')) { results.push(table); return; }
              if (anc.className && tableClassRegex.test(anc.className)) { results.push(table); return; }
            }
          } catch (e) { }
        });
        return Array.from(new Set(results));
      }

      function getPlayerNameCells() {
        const resultsTables = findResultsTables();
        const cells = [];
        if (!resultsTables || resultsTables.length === 0) return [];
        resultsTables.forEach(table => {
          try {
            const headerCells = Array.from(table.querySelectorAll('thead th, thead td'));
            const headerIdxs = [];
            if (headerCells.length) {
              headerCells.forEach((th, idx) => {
                if (!th || !th.textContent) return;
                const txt = th.textContent.trim();
                if (txt === '選手名稱' || /選手.*名稱|名稱.*選手|player.?name|選手/i.test(txt)) headerIdxs.push({ idx, th });
              });
            }
            if (headerIdxs.length === 0) {
              const firstRow = table.querySelector('tr');
              if (firstRow) {
                const tds = Array.from(firstRow.children).filter(c => c.tagName === 'TH' || c.tagName === 'TD');
                tds.forEach((cell, idx) => {
                  if (!cell || !cell.textContent) return;
                  const txt = cell.textContent.trim();
                  if (txt === '選手名稱' || /選手.*名稱|名稱.*選手|player.?name|選手/i.test(txt)) headerIdxs.push({ idx, th: cell });
                });
              }
            }
            if (headerIdxs.length === 0) {
              const direct = table.querySelectorAll('.player-name, .playerName, [data-col="player"], [data-col="player-name"], [data-field="playerName"], [data-header="選手名稱"]');
              direct.forEach(d => { const cell = d.closest('td,th') || d; if (cell) cells.push(cell); });
            } else {
              const tbodyRows = table.querySelectorAll('tbody tr, tr');
              headerIdxs.forEach(({ idx }) => {
                tbodyRows.forEach(row => {
                  const tds = Array.from(row.children).filter(c => c.tagName === 'TD' || c.tagName === 'TH');
                  if (tds[idx]) cells.push(tds[idx]);
                  else {
                    const alt = row.querySelector('[data-header="選手名稱"], .player-name, .playerName');
                    if (alt) cells.push(alt);
                  }
                });
              });
            }
          } catch (e) { }
        });
        return Array.from(new Set(cells)).filter(c => c && c.textContent && c.textContent.trim());
      }

      let shrinkObserver = null;
      function shrinkLatinDigitsInPlayerNamesOnce() {
        const cells = getPlayerNameCells();
        if (!cells || cells.length === 0) return;
        cells.forEach(cell => {
          try { processElementTextNodes(cell); } catch (e) { }
        });
      }

      function startPlayerNameObserver() {
        const resultsTables = findResultsTables();
        if (!resultsTables || resultsTables.length === 0) {
          if (shrinkObserver) try { shrinkObserver.disconnect(); } catch (e) { }
          shrinkObserver = new MutationObserver((mutations) => {
            if (shrinkObserver._timer) clearTimeout(shrinkObserver._timer);
            shrinkObserver._timer = setTimeout(() => {
              const tablesNew = findResultsTables();
              if (tablesNew.length) {
                shrinkLatinDigitsInPlayerNamesOnce();
                startPlayerNameObserver();
              }
            }, 200);
          });
          shrinkObserver.observe(document.body, { childList: true, subtree: true });
          return;
        }
        if (shrinkObserver) try { shrinkObserver.disconnect(); } catch (e) { }
        const targets = resultsTables.map(t => t.parentElement || t);
        shrinkObserver = new MutationObserver((mutations) => {
          if (shrinkObserver._timer) clearTimeout(shrinkObserver._timer);
          shrinkObserver._timer = setTimeout(() => { shrinkLatinDigitsInPlayerNamesOnce(); }, 150);
        });
        targets.forEach(t => { try { shrinkObserver.observe(t, { childList: true, subtree: true, characterData: true }); } catch (e) { } });
      }

      document.addEventListener('DOMContentLoaded', async () => {
        const pairBtn = document.getElementById('screenshotPairingsBtn');
        if (pairBtn) {
          pairBtn.addEventListener('contextmenu', async (e) => {
            e.preventDefault(); e.stopPropagation();
            const targetEl = document.getElementById('roundSection') || document.getElementById('pairings') || document.querySelector('.pairings, #pairingsTable') || document.body;
            if (!targetEl) { alert('找不到要截圖的對陣表元素 (id="roundSection")。'); return; }
            const rn = (typeof viewRound !== 'undefined' && viewRound) ? viewRound
              : ((typeof currentRound !== 'undefined' && currentRound) ? currentRound : 1);
            let defaultStart = null;
            try { defaultStart = (typeof computePredictedStartTimeForRound === 'function') ? computePredictedStartTimeForRound(rn) : addMinutesAndRoundUp(new Date().toISOString(), 3); }
            catch (e) { defaultStart = addMinutesAndRoundUp(new Date().toISOString(), 3); }
            let chosenDate = null;
            try {
              chosenDate = await showTimePickerModal(defaultStart);
            } catch (e) { chosenDate = null; }
            if (!chosenDate) return;
            try { await window.screenshotElementToClipboard(targetEl, { overrideStartDate: chosenDate }); }
            catch (err) { console.error('右鍵自定時間截圖失敗:', err); alert('截圖失敗:' + (err && err.message ? err.message : '未知錯誤')); }
          }, { passive: false });
        } else {
          console.warn('右鍵功能:找不到 #screenshotPairingsBtn');
        }

        try { shrinkLatinDigitsInPlayerNamesOnce(); startPlayerNameObserver(); } catch (e) { console.error(e); }
      });

    })(); 
  </script>
  <style>
    .submitted-badge {
      display: inline-block;
      background: #27ae60;
      color: #ffffff;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: 700;
      font-size: 1.05em;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.12);
    }
  </style>
</head>

<body>
  <div class="section competition-info" id="competitionHeader">
    <div class="header-top">
      <div class="header-left">
        <label>比賽名稱:
          <input type="text" id="tournamentName" placeholder="輸入比賽名稱">
        </label>
        <label>比賽日子:
          <input type="date" id="tournamentDate">
        </label>
        <label style="margin-left:10px;">比賽用時:
          <select id="timeControl">
            <optgroup label="包干制">
              <option value="10+0">每方10分鐘【包干制】</option>
              <option value="15+0">每方15分鐘【包干制】</option>
              <option value="20+0">每方20分鐘【包干制】</option>
              <option value="25+0">每方25分鐘【包干制】</option>
              <option value="30+0">每方30分鐘【包干制】</option>
              <option value="40+0">每方40分鐘【包干制】</option>
              <option value="45+0">每方45分鐘【包干制】</option>
              <option value="60+0">每方60分鐘【包干制】</option>
            </optgroup>
            <optgroup label="加秒制">
              <option value="5+5">基本時間5分鐘 · 每步加5秒【加秒制】</option>
              <option value="5+6">基本時間5分鐘 · 每步加6秒【加秒制】</option>
              <option value="10+6">基本時間10分鐘 · 每步加6秒【加秒制】</option>
              <option value="15+6">基本時間15分鐘 · 每步加6秒【加秒制】</option>
              <option value="25+6">基本時間25分鐘 · 每步加6秒【加秒制】</option>
              <option value="10+10">基本時間10分鐘 · 每步加10秒【加秒制】</option>
              <option value="10+20">基本時間10分鐘 · 每步加20秒【加秒制】</option>
            </optgroup>
            <optgroup label="讀秒制">
              <option value="0+3x10">不設基本時間 · 3次10秒【讀秒制】</option>
              <option value="25+3x10">基本時間25分鐘 · 3次10秒【讀秒制】</option>
              <option value="40+3x10">基本時間40分鐘 · 3次10秒【讀秒制】</option>
              <option value="55+3x10">基本時間55分鐘 · 3次10秒【讀秒制】</option>
            </optgroup>
          </select>
        </label>
      </div>

      <div class="header-right">
        <label class="state-checkbox-label" title="截圖時是否在右上加入賽事時間浮水印">
          <input type="checkbox" id="showEventTimeCheckbox" checked>
          賽事時間
        </label>
        <label class="state-checkbox-label" title="是否在排名拆分時使用「對手平均名次」作為條件">
          <input type="checkbox" id="useAvgOppRankCheckbox" checked>
          平均名次
        </label>
        <span>比賽輪數:</span>
        <div id="roundSelection" style="display:inline-block;">
          <button class="round-btn" data-round="3">3</button>
          <button class="round-btn" data-round="4">4</button>
          <button class="round-btn selected-round" data-round="5">5</button>
          <button class="round-btn" data-round="6">6</button>
          <button class="round-btn" data-round="7">7</button>
          <button class="round-btn" data-round="8">8</button>
        </div>
        <span style="margin-left:10px;">編排方式:</span>
        <div id="pairingMode" style="display:inline-block;">
          <button class="pairing-mode-btn" data-mode="Z">Z型</button>
          <button class="pairing-mode-btn selected-mode" data-mode="U">U型</button>
        </div>
        <button id="startTournamentBtn">開始比賽</button>
      </div>
    </div>
    <div class="header-tools">
      <div class="tools-left">
        <button id="togglePlayersSectionBtn">顯示選手</button>
        <button id="importStateBtn">上傳進度</button>
        <input type="file" id="importFileInput" style="display:none;" accept=".json">
        <button id="setFileHandleBtn">設置保存</button>
        <div id="roundNav" style="margin-top:8px; display:none;"></div>
      </div>
      <div class="tools-right">
        <button id="copyCertificateBtn">複製獎狀內容</button>
        <button id="screenshotPairingsBtn">截圖對陣表</button>
        <button id="printPairingsBtn">列印對陣表</button>
        <button id="screenshotScoreboardBtn">截圖成績總表</button>
        <button id="printScoreboardBtn">列印成績總表</button>
        <button id="exportAllExcelBtn">匯出成 Excel</button>
      </div>
    </div>

  </div>

  <div class="container">
    <div class="left">
      <div class="section" id="roundSection" style="display:none;">
        <h2 id="roundTitle">第1輪對陣表</h2>

        <div id="roundContainer"></div>
        <div class="round-controls">
          <div class="left-group">
            <button id="submitRoundBtn" style="display:none;">提交本輪結果</button>
            <button id="nextRoundBtn" style="display:none;">下一輪</button>
          </div>
          <div class="right-group">
            <button id="removeRoundBtn" style="display:none;">返回上一步</button>
          </div>
        </div>

      </div>
    </div>

    <div class="right" id="rightColumn">
      <div class="section" id="scoreboardSection" style="display:none;">
        <h2 id="scoreboardTitle">完成 0 輪後的成績總表</h2>
        <table id="scoreboard">
          <thead>
            <tr>
              <th>名次</th>
              <th>選手名稱</th>
              <th>評級·標記</th>
              <th>積分</th>
              <th>對手分</th>
              <th>對手分細節</th>
              <th>累積分</th>
              <th>累積分細節</th>
              <th>代表隊</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="section" id="playersSection">
        <h2>選手</h2>
        <textarea id="batchPlayers" placeholder="輸入選手名稱,每行一個或:姓名 代表隊" rows="10" style="width:90%;"></textarea>
        <div class="player-buttons">
          <button id="addBatchPlayersBtn">添加選手</button>
          <button id="randomizePlayersBtn">隨機生成</button>
          <button id="clearNumbersBtn">清除全部編號</button>
        </div>
        <ul id="playersList"></ul>
      </div>
    </div>
  </div>

  <script>
    let tournamentName = "";
    let tournamentDate = "";
    let timeControl = document.getElementById('timeControl').value;
    let players = [];
    let rounds = [];
    let currentRound = 0;
    let totalRounds = 5;
    let playerIdCounter = 1;
    let roundSubmitted = false;
    let competitionStarted = false;
    let viewRound = 0;
    let fileHandle = null;
    let selectedPlayer = null;
    let pairingMode = "U";
    let useAvgOppRank = true;
    let showEventTime = true;
    let tournamentFinishTime = null;

    document.addEventListener("DOMContentLoaded", () => {
      const tournamentDateInput = document.getElementById("tournamentDate");
      tournamentDateInput.value = new Date().toISOString().split('T')[0];

      const storedSettings = localStorage.getItem("tournamentSettings");
      if (storedSettings) {
        try {
          const settings = JSON.parse(storedSettings);
          if (typeof settings.useAvgOppRank === "boolean") {
            useAvgOppRank = settings.useAvgOppRank;
          }
        } catch (e) {
          console.warn("載入 settings 失敗", e);
        }
      }

      const useAvgOppRankCheckbox = document.getElementById("useAvgOppRankCheckbox");
      useAvgOppRankCheckbox.checked = useAvgOppRank;
      useAvgOppRankCheckbox.addEventListener("change", (e) => {
        useAvgOppRank = e.target.checked;
        try {
          localStorage.setItem("tournamentSettings", JSON.stringify({ useAvgOppRank }));
        } catch (err) {
          console.warn("儲存 settings 失敗", err);
        }
        updateScoreboardFor(currentRound);
        updatePlayersList();
        displayRound(viewRound);
        saveState();
      });

      const showEventTimeCheckbox = document.getElementById("showEventTimeCheckbox");
      if (showEventTimeCheckbox) {
        showEventTimeCheckbox.checked = true;
        showEventTimeCheckbox.addEventListener("change", (e) => {
          showEventTime = !!e.target.checked;
        });
      }

      const togglePlayersSectionBtn = document.getElementById("togglePlayersSectionBtn");
      const playersSection = document.getElementById("playersSection");
      const roundButtons = document.querySelectorAll('.round-btn');
      roundButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          if (competitionStarted) return;
          totalRounds = parseInt(btn.dataset.round, 10);
          roundButtons.forEach(b => b.classList.remove('selected-round'));
          btn.classList.add('selected-round');
          saveState();
        });
      });
      togglePlayersSectionBtn.addEventListener("click", () => {
        const playersSection = document.getElementById('playersSection');
        if (!playersSection) return;
        const open = playersSection.classList.toggle('open');
        togglePlayersSectionBtn.textContent = open ? "隱藏選手" : "顯示選手";
      });


      updateLayoutBasedOnWidth();
      const scoreboardSection = document.getElementById('scoreboardSection');
      if (scoreboardSection && !competitionStarted && (!rounds || rounds.length === 0)) {
        scoreboardSection.style.display = 'none';
      }
    });

    document.getElementById('timeControl').addEventListener('change', e => {
      timeControl = e.target.value;
      saveState();
    });

    document.querySelectorAll('.pairing-mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (competitionStarted) return;
        pairingMode = btn.dataset.mode;
        document.querySelectorAll('.pairing-mode-btn').forEach(b => b.classList.remove('selected-mode'));
        btn.classList.add('selected-mode');
        saveState();
      });

      const timeControlSelect = document.getElementById('timeControl');
      if (timeControlSelect) {
        timeControlSelect.value = '25+0';
        timeControl = timeControlSelect.value;
      }

    });

    const tournamentNameInput = document.getElementById("tournamentName");
    const tournamentDateInput = document.getElementById("tournamentDate");
    const startTournamentBtn = document.getElementById("startTournamentBtn");

    document.addEventListener('DOMContentLoaded', () => {
      const pairBtn = document.getElementById('screenshotPairingsBtn');
      const sbBtn = document.getElementById('screenshotScoreboardBtn');

      if (pairBtn) {
        pairBtn.addEventListener('click', async () => {
          const el = document.getElementById('roundSection');
          if (!el) { alert('找不到對陣表元素 (id=roundSection)'); return; }
          try {
            await screenshotElementToClipboard(el);
          } catch (err) { }
        });
      }

      if (sbBtn) {
        sbBtn.addEventListener('click', async () => {
          const el = document.getElementById('scoreboardSection');
          if (!el) { alert('找不到成績總表元素 (id=scoreboardSection)'); return; }
          try {
            await screenshotElementToClipboard(el);
          } catch (err) { }
        });
      }
    });

    function computePageTitle(fullName) {
      const name = fullName.trim();
      if (!name) return 'Competition Arrangement System';
      const parts = name.split(/\s+/);
      return parts.length > 1 ? parts[parts.length - 1] : parts[0];
    }

    function updateDocumentTitle() {
      document.title = computePageTitle(tournamentName);
    }
    tournamentNameInput.addEventListener('input', () => {
      tournamentName = tournamentNameInput.value;
      updateDocumentTitle();
    });

    const roundSection = document.getElementById("roundSection");
    const roundTitle = document.getElementById("roundTitle");
    const roundContainer = document.getElementById("roundContainer");
    const submitRoundBtn = document.getElementById("submitRoundBtn");
    const nextRoundBtn = document.getElementById("nextRoundBtn");
    const removeRoundBtn = document.getElementById("removeRoundBtn");
    const scoreboardBody = document.querySelector("#scoreboard tbody");
    const scoreboardTitle = document.getElementById("scoreboardTitle");
    const roundSelectionDiv = document.getElementById("roundSelection");
    const selectedRoundSpan = document.getElementById("selectedRound");
    const togglePlayersSectionBtnRef = document.getElementById("togglePlayersSectionBtn");
    const batchPlayersTextarea = document.getElementById("batchPlayers");
    const addBatchPlayersBtn = document.getElementById("addBatchPlayersBtn");
    const randomizePlayersBtn = document.getElementById("randomizePlayersBtn");
    const clearNumbersBtn = document.getElementById("clearNumbersBtn");
    const playersList = document.getElementById("playersList");

    addBatchPlayersBtn.addEventListener("click", () => {
      const text = batchPlayersTextarea.value.trim();
      if (!text) {
        alert("請輸入至少一個選手名稱！");
        return;
      }
      const lines = text.split("\n")
        .map(line => line.trim())
        .filter(line => line.length > 0);
      lines.forEach(line => {
        const parts = line.split(/\s+/);
        const name = parts[0];
        const team = parts.length > 1 ? parts.slice(1).join(" ") : "";
        players.push({
          id: playerIdCounter,
          number: playerIdCounter,
          name: name,
          team: team,
          isLocked: false,
          matchPoints: 0,
          pointsHistory: [],
          cumulativeScore: 0,
          opponents: [],
          roundResults: [],
          hadBye: false,
          isFinalist: false,
          isFemale: false,
          isCancelled: false,
          rank: "",
          withdrawn: false
        });
        playerIdCounter++;
      });
      batchPlayersTextarea.value = "";
      updatePlayersList();
      saveState();
      updateLayoutBasedOnWidth();
    });

    clearNumbersBtn.addEventListener("click", () => {
      if (confirm("確定要清除所有選手的編號並解除鎖定？")) {
        players.forEach(player => {
          player.number = "";
          player.isLocked = false;
        });
        updatePlayersList();
        saveState();
      }
    });

    async function screenshotElementToClipboard(element, options = {}) {
      if (!element) throw new Error('element is required');
      if (typeof html2canvas === 'undefined') {
        alert('截圖工具 (html2canvas) 尚未載入,請在 head 引入 script。');
        return;
      }

      try {
        if (document.fonts && typeof document.fonts.ready !== 'undefined') {
          await document.fonts.ready;
        } else {
          await new Promise(r => setTimeout(r, 250));
        }
      } catch (e) { }

      let overrideStartDate = null;
      if (options && options.overrideStartDate) {
        const v = options.overrideStartDate;
        overrideStartDate = (v instanceof Date) ? v : new Date(v);
        if (!(overrideStartDate instanceof Date) || isNaN(overrideStartDate)) {
          overrideStartDate = null;
        }
      }

      const timeControlSelect = document.getElementById("timeControl");
      const timeControlText = timeControlSelect ? timeControlSelect.options[timeControlSelect.selectedIndex].text : '';
      const footerFull = '名次排序依序比較積分、對手分及累積分(高分優先)。若仍相同,則根據對手的平均名次決定(對手平均排名靠前者優先)。';
      const footerShort = '名次排序依序比較積分、對手分及累積分(高分優先)。';
      const footerText = (typeof useAvgOppRank !== 'undefined' && useAvgOppRank) ? footerFull : footerShort;

      const tmp = document.createElement('div');
      tmp.id = 'tmpScreenshotContainer';
      tmp.style.position = 'fixed';
      tmp.style.left = '-9999px';
      tmp.style.top = '0';
      tmp.style.zIndex = '2147483647';
      tmp.style.boxSizing = 'border-box';
      tmp.style.background = '#ffffff';
      tmp.style.color = getComputedStyle(document.body).color || '#222';
      tmp.style.fontFamily = "'Noto Sans TC', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif";
      tmp.style.webkitFontSmoothing = 'antialiased';
      tmp.style.mozOsxFontSmoothing = 'grayscale';
      tmp.style.lineHeight = getComputedStyle(document.body).lineHeight || '1.2';
      tmp.style.padding = '6px';
      tmp.style.overflow = 'visible';

      const headerRow = document.createElement('div');
      headerRow.style.display = 'flex';
      headerRow.style.justifyContent = 'space-between';
      headerRow.style.alignItems = 'flex-start';
      headerRow.style.borderBottom = 'none';
      headerRow.style.padding = '6px 8px 6px 8px';
      headerRow.style.boxSizing = 'border-box';

      const header = document.createElement('div');
      header.style.textAlign = 'center';
      if (showEventTime) { header.style.textAlign = 'left'; }
      header.style.margin = '0';
      header.style.flex = '1 1 auto';
      header.style.padding = '0';

      const h1 = document.createElement('h1');
      h1.style.margin = '0';
      h1.style.padding = '0';
      h1.style.lineHeight = '1.05';
      h1.style.fontSize = '24px';
      h1.style.fontWeight = '700';
      h1.textContent = (typeof tournamentName !== 'undefined' && tournamentName) ? tournamentName : '';

      const p = document.createElement('p');
      p.style.margin = '8px 0 0 0';
      p.style.padding = '0';
      p.style.fontSize = '13px';
      p.style.lineHeight = '1.1';
      p.textContent = `${(typeof tournamentDate !== 'undefined' && tournamentDate) ? tournamentDate : ''}  ||  共 ${totalRounds || ''} 輪  ||  ${timeControlText}`;

      header.appendChild(h1);
      header.appendChild(p);
      headerRow.appendChild(header);

      const topRightBox = document.createElement('div');
      topRightBox.style.textAlign = 'right';
      topRightBox.style.fontSize = '12px';
      topRightBox.style.lineHeight = '1.2';
      topRightBox.style.color = '#333';
      topRightBox.style.maxWidth = '40%';
      topRightBox.style.zIndex = '2147483649';
      topRightBox.style.flex = '0 0 auto';
      topRightBox.style.margin = '0';
      topRightBox.style.padding = '0';
      headerRow.appendChild(topRightBox);

      tmp.appendChild(headerRow);

      const clone = element.cloneNode(true);
      clone.style.boxSizing = 'border-box';
      clone.style.width = '100%';
      clone.style.margin = '0';
      clone.querySelectorAll('button, input[type="button"], input[type="file"], input[type="submit"]').forEach(b => {
        b.style.display = 'none';
      });

      clone.querySelectorAll('hr').forEach(hr => hr.parentNode && hr.parentNode.removeChild(hr));

      if (clone.firstElementChild) {
        clone.firstElementChild.style.borderTop = 'none';
        clone.firstElementChild.style.marginTop = '0';
        clone.firstElementChild.style.paddingTop = clone.firstElementChild.style.paddingTop || '0';
      }

      tmp.appendChild(clone);

      const shouldAddFooter = (element.id === 'scoreboardSection' || (element.closest && element.closest('#scoreboardSection')));
      if (shouldAddFooter) {
        const footer = document.createElement('div');
        footer.style.padding = '8px';
        footer.style.borderTop = '1px solid rgba(0,0,0,0.06)';
        footer.style.fontSize = '14px';
        footer.style.textAlign = 'center';
        if (showEventTime) { header.style.textAlign = 'left'; }
        footer.textContent = footerText;
        tmp.appendChild(footer);
      }
      if (element.id === 'roundSection' || (element.closest && element.closest('#roundSection'))) {
        const pairingsFooter = document.createElement('div');
        pairingsFooter.style.padding = '8px';
        pairingsFooter.style.fontSize = '14px';
        pairingsFooter.style.textAlign = 'center';
        pairingsFooter.style.color = 'rgba(0,0,0,0.6)';
        pairingsFooter.style.marginTop = '6px';
        pairingsFooter.textContent = '#n: 至此輪為止,該選手與不同積分對手(或輪空)交手的累計次數。';
        tmp.appendChild(pairingsFooter);
      }

      try {
        function formatTime(isoStrOrDate) {
          if (!isoStrOrDate) return '';
          const d = (typeof isoStrOrDate === 'string') ? new Date(isoStrOrDate) : new Date(isoStrOrDate);
          if (!(d instanceof Date) || isNaN(d)) return '';
          return d.toTimeString().split(' ')[0];
        }
        function addMinutesAndRoundUp(dateISOorDate, addMinutes) {
          if (!dateISOorDate) return null;
          const d = (dateISOorDate instanceof Date) ? new Date(dateISOorDate) : new Date(dateISOorDate);
          if (!(d instanceof Date) || isNaN(d)) return null;
          d.setMinutes(d.getMinutes() + addMinutes);
          if (d.getSeconds() > 0 || d.getMilliseconds() > 0) {
            d.setSeconds(0);
            d.setMilliseconds(0);
            d.setMinutes(d.getMinutes() + 1);
          } else {
            d.setSeconds(0);
            d.setMilliseconds(0);
          }
          return d;
        }

        if (showEventTime) {
          if (element.id === 'roundSection') {
            const rn = viewRound || currentRound || 1;
            if (rn > 1) {
              const roundObj = rounds && rounds[rn - 1] ? rounds[rn - 1] : null;
              const arrangedISO = (roundObj && roundObj.arrangedAt) ? roundObj.arrangedAt : null;
              const arrangedDisplay = arrangedISO ? formatTime(arrangedISO) : formatTime(new Date());
              const playersCount = (players || []).filter(p => !p.withdrawn).length || 0;
              let extra = 0;
              if (playersCount >= 24) extra++;
              if (playersCount >= 32) extra++;
              if (playersCount >= 40) extra++;
              const startDate = overrideStartDate
                ? overrideStartDate
                : addMinutesAndRoundUp(arrangedISO ? arrangedISO : new Date().toISOString(), 3 + extra);

              const startDisplay = startDate ? formatTime(startDate) : '';

              const line1 = document.createElement('div');
              line1.textContent = `第${rn}輪賽事 對陣表編排時間: ${arrangedDisplay}`;
              line1.style.fontSize = '14px';
              line1.style.fontWeight = '700';
              topRightBox.appendChild(line1);

              const spacer = document.createElement('div');
              spacer.style.height = '6px';
              topRightBox.appendChild(spacer);

              const line2 = document.createElement('div');
              line2.textContent = overrideStartDate
                ? `第${rn}輪賽事 開賽時間: ${startDisplay}`
                : `第${rn}輪賽事 預計開賽時間: ${startDisplay}`;
              line2.style.fontSize = '17px';
              line2.style.fontWeight = '700';
              line2.style.background = '#FDFD0D';
              topRightBox.appendChild(line2);
            }
          }
          if (element.id === 'scoreboardSection' || (element.closest && element.closest('#scoreboardSection'))) {
            if (tournamentFinishTime) {
              const finishDisplay = formatTime(tournamentFinishTime);
              const line = document.createElement('div');
              line.textContent = `比賽完成時間為: ${finishDisplay}`;
              line.style.fontSize = '17px';
              line.style.fontWeight = '700';
              line.style.background = '#FDFD0D';
              topRightBox.appendChild(line);
            }
          }
        }
      } catch (err) {
        console.warn('建立浮水印時發生錯誤', err);
      }

      document.body.appendChild(tmp);

      const imgs = Array.from(tmp.querySelectorAll('img'));
      if (imgs.length) {
        await Promise.all(imgs.map(img => new Promise(res => {
          if (img.complete) return res();
          img.onload = img.onerror = res;
        })));
      }

      const rect = element.getBoundingClientRect();
      tmp.style.width = Math.ceil(rect.width) + 'px';

      try {
        const dpr = window.devicePixelRatio || 1;
        const multiplier = 4;
        const scale = Math.min(4, Math.max(1, Math.round(dpr * multiplier)));

        const canvas = await html2canvas(tmp, {
          scale,
          useCORS: true,
          allowTaint: false,
          backgroundColor: '#ffffff',
          logging: false,
          imageTimeout: 30000
        });

        try {
          const ctx = canvas.getContext && canvas.getContext('2d');
          if (ctx) {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
          }
        } catch (e) {
          console.warn('設定 canvas smoothing 失敗', e);
        }

        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
        if (!blob) throw new Error('無法產生截圖 Blob');

        async function tryWriteImageToClipboard(blob) {
          if (navigator.clipboard && window.ClipboardItem) {
            try {
              await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
              return true;
            } catch (err) {
              console.warn('clipboard.write 失敗:', err);
            }
          }

          if (navigator.permissions && navigator.permissions.query) {
            try {
              const perm = await navigator.permissions.query({ name: 'clipboard-write' });
              if (perm && (perm.state === 'granted' || perm.state === 'prompt')) {
                if (navigator.clipboard && window.ClipboardItem) {
                  try {
                    await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
                    return true;
                  } catch (err) {
                    console.warn('在 permission 後再嘗試 clipboard.write 仍失敗:', err);
                  }
                }
              }
            } catch (err) {
              console.warn('permissions.query 不支援或失敗:', err);
            }
          }

          return false;
        }

        function showImageModalForManualCopy(blob) {
          const url = URL.createObjectURL(blob);

          const overlay = document.createElement('div');
          overlay.style.position = 'fixed';
          overlay.style.left = '0';
          overlay.style.top = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.background = 'rgba(0,0,0,0.6)';
          overlay.style.display = 'flex';
          overlay.style.alignItems = 'center';
          overlay.style.justifyContent = 'center';
          overlay.style.zIndex = 2147483648;

          const box = document.createElement('div');
          box.style.background = '#fff';
          box.style.padding = '12px';
          box.style.borderRadius = '8px';
          box.style.maxWidth = '92vw';
          box.style.maxHeight = '90vh';
          box.style.overflow = 'auto';
          box.style.textAlign = 'center';
          box.style.boxShadow = '0 8px 32px rgba(0,0,0,0.25)';
          box.style.display = 'flex';
          box.style.flexDirection = 'column';
          box.style.alignItems = 'center';
          box.style.gap = '10px';

          const img = document.createElement('img');
          img.src = url;
          img.alt = '截圖預覽';
          img.style.maxWidth = '80vw';
          img.style.maxHeight = '60vh';
          img.style.border = '1px solid #eee';
          img.style.borderRadius = '4px';

          const info = document.createElement('div');
          info.style.fontSize = '14px';
          info.style.color = '#333';
          info.style.maxWidth = '80vw';
          info.style.lineHeight = '1.4';
          info.innerHTML = `無法直接複製到系統剪貼簿。你可以按下「複製圖片到剪貼簿」或使用右鍵選單「複製圖片」。`;

          const controls = document.createElement('div');
          controls.style.display = 'flex';
          controls.style.gap = '8px';
          controls.style.alignItems = 'center';

          const btnCopy = document.createElement('button');
          btnCopy.textContent = '複製圖片到剪貼簿';
          btnCopy.style.padding = '8px 12px';
          btnCopy.style.borderRadius = '6px';
          btnCopy.style.border = '1px solid #2a9146';
          btnCopy.style.background = '#2da44e';
          btnCopy.style.color = '#fff';
          btnCopy.onclick = async () => {
            btnCopy.disabled = true;
            btnCopy.textContent = '嘗試複製中...';
            try {
              const ok = await tryWriteImageToClipboard(blob);
              if (ok) {
                btnCopy.textContent = '已複製到剪貼簿';
                setTimeout(() => {
                  if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
                  URL.revokeObjectURL(url);
                }, 800);
              } else {
                btnCopy.textContent = '複製失敗,請右鍵複製';
                btnCopy.disabled = false;
              }
            } catch (err) {
              console.error('手動複製發生例外:', err);
              btnCopy.textContent = '複製失敗,請右鍵複製';
              btnCopy.disabled = false;
            }
          };

          const btnClose = document.createElement('button');
          btnClose.textContent = '關閉';
          btnClose.style.padding = '8px 12px';
          btnClose.style.borderRadius = '6px';
          btnClose.style.border = '1px solid #ccc';
          btnClose.style.background = '#fff';
          btnClose.onclick = () => {
            if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
            URL.revokeObjectURL(url);
          };

          controls.appendChild(btnCopy);
          controls.appendChild(btnClose);

          box.appendChild(img);
          box.appendChild(info);
          box.appendChild(controls);
          overlay.appendChild(box);
          document.body.appendChild(overlay);
        }

        let wrote = false;
        try {
          wrote = await tryWriteImageToClipboard(blob);
        } catch (err) {
          console.warn('嘗試寫入剪貼簿時發生例外:', err);
          wrote = false;
        }

        if (wrote) {
          try {
            const toast = document.createElement('div');
            toast.textContent = '截圖已複製到剪貼簿';
            toast.style.position = 'fixed';
            toast.style.right = '20px';
            toast.style.bottom = '24px';
            toast.style.zIndex = 2147483648;
            toast.style.padding = '8px 12px';
            toast.style.background = 'rgba(0,0,0,0.8)';
            toast.style.color = '#fff';
            toast.style.borderRadius = '6px';
            toast.style.fontSize = '13px';
            document.body.appendChild(toast);
            setTimeout(() => {
              if (toast && toast.parentNode) toast.parentNode.removeChild(toast);
            }, 1400);
          } catch (e) {
          } finally {
            if (tmp && tmp.parentNode) tmp.parentNode.removeChild(tmp);
          }
          return;
        }

        showImageModalForManualCopy(blob);

        if (tmp && tmp.parentNode) tmp.parentNode.removeChild(tmp);
        return;
      } catch (err) {
        if (tmp && tmp.parentNode) tmp.parentNode.removeChild(tmp);
        console.error('截圖錯誤:', err);
        alert('截圖失敗:' + (err && err.message ? err.message : err));
        return;
      }
    }


    function toggleWithdraw(playerId) {
      const player = players.find(p => p.id === playerId);
      if (!player) return;
      player.withdrawn = !player.withdrawn;
      updatePlayersList();
      saveState();
    }

    window.updatePlayerName = function (inputElem) {
      try {
        const playerId = parseInt(inputElem.dataset.id, 10);
        const newName = String(inputElem.value || '').trim();
        const player = players.find(p => p.id === playerId);
        if (!player) return;
        player.name = newName;
        refreshNamesInRoundTable(playerId, newName);
        try { updateScoreboardFor(currentRound); } catch (e) { console.warn('updateScoreboardFor error', e); }
        saveState();
      } catch (err) {
        console.warn('updatePlayerName error', err);
      }
    };

    window.debouncedPlayerNameChange = function (inputElem) {
      try {
        if (!inputElem) return;
        if (inputElem._nameTimer) clearTimeout(inputElem._nameTimer);
        inputElem._nameTimer = setTimeout(() => {
          window.updatePlayerName(inputElem);
          inputElem._nameTimer = null;
        }, 600);
      } catch (err) {
        console.warn('debouncedPlayerNameChange error', err);
      }
    };

    function refreshNamesInRoundTable(playerId, newName) {
      try {
        if (!playerId) return;
        const container = document.getElementById('roundContainer');
        if (!container) return;
        const els = container.querySelectorAll('.player-name[data-player-id]');
        els.forEach(el => {
          if (String(el.dataset.playerId) === String(playerId)) {
            const nameSpan = el.querySelector('.print-player-name');
            if (nameSpan) {
              nameSpan.textContent = newName;
            } else {
              el.textContent = newName;
            }
          }
        });
      } catch (err) {
        console.warn('refreshNamesInRoundTable error', err);
      }
    }

    (function () {
      const playersSection = document.getElementById('playersSection');
      const toggleBtn = document.getElementById('togglePlayersSectionBtn');
      if (!playersSection || !toggleBtn) return;

      function closePlayersSection() {
        if (!playersSection.classList.contains('open')) return;
        playersSection.classList.remove('open');
        toggleBtn.textContent = "顯示選手";
      }

      document.addEventListener('click', function (evt) {
        try {
          if (!playersSection.classList.contains('open')) return;
          const tgt = evt.target;
          if (playersSection.contains(tgt) || toggleBtn.contains(tgt)) return;
          closePlayersSection();
        } catch (e) {
          console.warn('close players on outside click error', e);
        }
      }, true);
      document.addEventListener('touchstart', function (evt) {
        try {
          if (!playersSection.classList.contains('open')) return;
          const tgt = evt.target;
          if (playersSection.contains(tgt) || toggleBtn.contains(tgt)) return;
          closePlayersSection();
        } catch (e) {
          console.warn('close players on touchstart error', e);
        }
      }, { passive: true, capture: true });
    })();

    window.deletePlayer = function (playerId) {
      if (competitionStarted) {
        alert("比賽已開始,無法刪除選手！");
        return;
      }
      const player = players.find(p => p.id === playerId);
      if (!player) return;
      if (!confirm(`確定要刪除選手:${player.name}？此操作無法還原。`)) return;
      players = players.filter(p => p.id !== playerId);
      updatePlayersList();
      saveState();
    };

    let playerRankOrder = [];
    function updatePlayersList() {
      updateScoreboardFor(currentRound);
      const order = playerRankOrder.length ? playerRankOrder : players.map(p => p.id);
      playersList.innerHTML = '';
      order.forEach(id => {
        const player = players.find(p => p.id === id);
        if (!player) return;
        const li = document.createElement('li');
        li.className = 'player-item';
        const lockIcon = player.isLocked ? '🔒' : '🔓';
        const numberCol = `
  <div class="col col-number">
    ${!competitionStarted
            ? `<div style="display:flex; align-items:center; gap:6px; justify-content:center;">
           <input type="text" value="${player.number}" data-id="${player.id}" onchange="updatePlayerNumber(this)" />
           <button onclick="toggleLock(${player.id})" class="marker-btn" style="min-width:36px; padding:2px 6px;">${lockIcon}</button>
         </div>`
            : `<div style="text-align:center;">#${player.number || ''}</div>`}
  </div>
`;

        const nameCol = `
  <div class="col col-name">
    ${!competitionStarted
            ? `<div class="player-name" style="font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; text-align:center;">
           ${escapeHtml(player.name)}
         </div>`
            : `<div style="display:flex; justify-content:center;">
           <input type="text"
                  value="${escapeHtml(player.name)}"
                  data-id="${player.id}"
                  onchange="updatePlayerName(this)"
                  oninput="debouncedPlayerNameChange(this)"
                  style="width:84%; padding:4px; box-sizing:border-box; border-radius:4px; border:1px solid #ddd; text-align:center;" />
         </div>`
          }
  </div>
`;

        const finalistCol = competitionStarted ? `
  <div class="col col-finalist" style="display:flex; justify-content:center;">
    <button onclick="toggleMarker(${player.id}, '入選')" class="marker-btn ${player.isFinalist ? 'selected-marker' : ''}">入選</button>
  </div>
` : '';

        const femaleCol = `
  <div class="col col-female" style="display:flex; justify-content:center;">
    <button onclick="toggleMarker(${player.id}, '女棋手')" class="marker-btn ${player.isFemale ? 'selected-marker' : ''}">FEMALE</button>
  </div>
`;

        const cancelCol = competitionStarted ? `
  <div class="col col-cancel" style="display:flex; justify-content:center;">
    <button onclick="toggleMarker(${player.id}, '取消成績')" class="marker-btn ${player.isCancelled ? 'selected-marker' : ''}">取消</button>
  </div>
` : '';

        const rankCol = competitionStarted ? `
  <div class="col col-rank" style="display:flex; justify-content:center;">
    <select onchange="setRank(${player.id}, this.value)">
      <option value="">評為</option>
      ${Array.from({ length: 29 }, (_, i) => 29 - i).map(lvl => `<option value="${lvl}級" ${player.rank === `${lvl}級` ? 'selected' : ''}>${lvl}級</option>`).join('')}
      ${[1, 2, 3, 4, 5, 6, 7, 8].map(d => `<option value="${d}段" ${player.rank === `${d}段` ? 'selected' : ''}>${d}段</option>`).join('')}
    </select>
  </div>
` : '';

        const deleteCol = !competitionStarted ? `
  <div class="col col-delete" style="display:flex; justify-content:center;">
    <button onclick="deletePlayer(${player.id})" class="player-action-btn" style="background:#e74c3c; border-color:#c0392b;">刪除</button>
  </div>
` : '';

        const actionCol = competitionStarted ? `
  <div class="col col-action" style="display:flex; justify-content:center;">
    ${player.withdrawn
            ? `<button onclick="toggleWithdraw(${player.id})" class="player-action-btn" style="background:#f1c40f; border-color:#e6b800; color:#000;">恢復</button>`
            : `<button onclick="toggleWithdraw(${player.id})" class="player-action-btn">退賽</button>`}
  </div>
` : deleteCol;

        li.innerHTML = `
  <div class="player-details-grid">
    ${numberCol}
    ${nameCol}
    ${finalistCol}
    ${femaleCol}
    ${cancelCol}
    ${rankCol}
    ${actionCol}
  </div>
`;
        playersList.appendChild(li);
      });

      saveState();
      updateLayoutBasedOnWidth();
    }

    window.toggleMarker = function (playerId, markerType) {
      const player = players.find(p => p.id === playerId);
      if (!player) return;
      switch (markerType) {
        case '入選':
          player.isFinalist = !player.isFinalist;
          break;
        case '女棋手':
          player.isFemale = !player.isFemale;
          break;
        case '取消成績':
          player.isCancelled = !player.isCancelled;
          break;
      }
      updatePlayersList();
      updateScoreboardFor(currentRound);
      saveState();
    };

    window.setRank = function (playerId, value) {
      const player = players.find(p => p.id === playerId);
      if (!player) return;
      player.rank = value;
      updatePlayersList();
      updateScoreboardFor(currentRound);
      saveState();
    };

    window.toggleLock = function (playerId) {
      const player = players.find(p => p.id === playerId);
      if (player) {
        player.isLocked = !player.isLocked;
      }
      updatePlayersList();
      saveState();
    };

    window.updatePlayerNumber = function (inputElem) {
      let playerId = parseInt(inputElem.dataset.id);
      let newNum = parseInt(inputElem.value.trim(), 10);
      if (isNaN(newNum)) {
        alert("請輸入有效的數字");
        inputElem.value = "";
        return;
      }
      if (newNum < 1 || newNum > players.length) {
        alert("編號必須在 1 到 " + players.length + " 之間");
        inputElem.value = "";
        return;
      }
      const duplicate = players.some(p => p.id !== playerId && Number(p.number) === newNum);
      if (duplicate) {
        alert("該編號已被使用,請選擇其他編號");
        inputElem.value = "";
        return;
      }
      let player = players.find(p => p.id === playerId);
      if (player) {
        player.number = newNum;
      }
      updatePlayersList();
      saveState();
    };

    randomizePlayersBtn.addEventListener("click", () => {
      if (competitionStarted) return;
      randomizePlayerNumbers();
      updatePlayersList();
      saveState();
    });

    function randomizePlayerNumbers() {
      const total = players.length;
      let availableNumbers = Array.from({ length: total }, (_, i) => i + 1);
      players.forEach(player => {
        if (player.isLocked) {
          const index = availableNumbers.indexOf(Number(player.number));
          if (index !== -1) {
            availableNumbers.splice(index, 1);
          }
        }
      });
      for (let i = availableNumbers.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        [availableNumbers[i], availableNumbers[j]] = [availableNumbers[j], availableNumbers[i]];
      }
      players.forEach(player => {
        if (!player.isLocked && availableNumbers.length > 0) {
          player.number = availableNumbers.shift();
        }
      });
    }

    startTournamentBtn.addEventListener("click", async () => {
      tournamentName = tournamentNameInput.value.trim();
      tournamentDate = tournamentDateInput.value;
      if (tournamentName === "") {
        alert("請輸入比賽名稱！");
        return;
      }
      updateDocumentTitle();
      if (tournamentDate === "") {
        alert("請選擇比賽日子！");
        return;
      }
      if (!totalRounds) {
        alert("請選擇比賽輪數！");
        return;
      }
      if (players.length < 2) {
        alert("請至少添加兩名選手！");
        return;
      }
      try {
        fileHandle = await window.showSaveFilePicker({
          suggestedName: tournamentName + ".json",
          types: [{
            description: "JSON Files",
            accept: { "application/json": [".json"] }
          }]
        });
      } catch (err) {
        alert("無法建立保存檔:" + err);
        return;
      }
      competitionStarted = true;
      startTournamentBtn.style.display = 'none';
      roundSubmitted = false;
      startTournamentBtn.disabled = true;
      tournamentNameInput.disabled = true;
      tournamentDateInput.disabled = true;
      document.querySelectorAll(".round-btn").forEach(btn => { btn.disabled = true; });
      document.getElementById('batchPlayers').style.display = 'none';
      document.getElementById('addBatchPlayersBtn').style.display = 'none';
      document.getElementById('randomizePlayersBtn').style.display = 'none';
      document.getElementById('clearNumbersBtn').style.display = 'none';
      const playersSection = document.getElementById("playersSection");
      playersSection.classList.remove('open');
      togglePlayersSectionBtnRef.style.display = "inline-block";
      togglePlayersSectionBtnRef.textContent = "顯示選手";
      addBatchPlayersBtn.disabled = true;
      randomizePlayersBtn.disabled = true;
      batchPlayersTextarea.disabled = true;
      roundSection.style.display = "block";
      if (scoreboardSection) scoreboardSection.style.display = 'block';
      currentRound = 1;
      viewRound = 1;
      let roundNavDiv = document.getElementById("roundNav");
      roundNavDiv.innerHTML = "";
      for (let i = 1; i <= totalRounds; i++) {
        let btn = document.createElement("button");
        btn.textContent = "第" + i + "輪";
        btn.dataset.round = i;
        btn.addEventListener("click", () => {
          displayRound(i);
        });
        roundNavDiv.appendChild(btn);
      }
      roundNavDiv.style.display = "block";
      displayRound(currentRound);
      updatePlayersList();
      updateScoreboardFor(currentRound);
      updatePlayersList();
      saveState();
      document.querySelectorAll('.pairing-mode-btn').forEach(btn => {
        if (!btn.classList.contains('selected-mode')) {
          btn.style.display = 'none';
        } else {
          btn.disabled = true;
          btn.style.display = '';
        }
      });
      document.querySelectorAll('.round-btn').forEach(btn => {
        if (!btn.classList.contains('selected-round')) {
          btn.style.display = 'none';
        } else {
          btn.disabled = true;
          btn.style.display = 'inline-block';
        }
      });

      recalculatePlayerStatsUpTo(currentRound);
      updateUI();
      updateLayoutBasedOnWidth();
    });

    // 段落說明:整個函式入口,負責依據目前玩家資料、輪次與配對模式產生本輪配對,包含處理輪空(bye)、回溯配對、微調(safe micro-adjust)、三向循環嘗試、以及調整左右(上下場次/高分在左等)與最終排序。 // 整體說明
    function generatePairingsByMode() { // 定義主函式:產生配對。 

      // 段落說明:準備活動玩家清單、判斷是否需要輪空、以及初始化 working 變數。 // 初始設定
      const allActive = players.filter(p => !p.withdrawn); // 取得所有未棄權的玩家清單。 
      const allowBye = allActive.length % 2 === 1; // 如果玩家數為奇數,允許安排輪空(bye)。 
      let active = [...allActive]; // 建立 active 的複本以便後續操作(不直接改動原陣列)。 
      let byePair = null; // 初始化輪空配對(若有的話會放在這裡)。 

      // 段落說明:取得某玩家在剩餘玩家中的候選配對名單(先同分,再跨分並做排序)。 // 產生候選人清單的輔助函式
      function getCandidates(p, remaining) { // 定義 getCandidates(p, remaining):回傳 p 的候選對手列表(基於未對戰過、分數群、排序規則)。 
        const noPlayed = remaining.filter(q => !p.opponents.includes(q.id)); // 過濾掉已經對過的玩家(只保留未對過的)。 

        const same = noPlayed.filter(q => q.matchPoints === p.matchPoints); // 同分群(與 p 分數相同的候選人)。 
        const cross = noPlayed.filter(q => q.matchPoints !== p.matchPoints) // 跨分群(分數不同)。
          .sort((a, b) => { // 對跨分群排序:先比分差,再依當前輪奇偶與編號做穩定排序。
            const da = Math.abs(p.matchPoints - a.matchPoints); // 計算 p 與 a 的分差絕對值。 
            const db = Math.abs(p.matchPoints - b.matchPoints); // 計算 p 與 b 的分差絕對值。 
            if (da !== db) return da - db; // 分差小者優先。 
            if (currentRound % 2 === 0) { // 若為偶數輪,使用特定的 tiebreak(高/低編號帶符號處理)。
              const ka = a.matchPoints < p.matchPoints ? -a.number : a.number; // 若 a 分數較低則反號以改變排序方向。 
              const kb = b.matchPoints < p.matchPoints ? -b.number : b.number; // 同上,針對 b。 
              return ka - kb; // 比較 ka, kb 以決定順序。 
            }
            return b.number - a.number; // 若為奇數輪則以編號遞減排序(高號先)。 
          });

        if (pairingMode === 'U') { // 若配對模式為 U(某種自定義規則),就對 same 做特定排序。 
          same.sort((a, b) => (currentRound % 2 === 1) ? b.number - a.number : a.number - b.number); // U 模式:奇數輪高號先,偶數輪低號先。 
        } else if (pairingMode === 'Z') { // 若配對模式為 Z,採另一種排序。 
          same.sort((a, b) => (currentRound % 2 === 1) ? a.number - b.number : b.number - a.number); // Z 模式:奇數輪低號先,偶數輪高號先。 
        } else {
          same.sort((a, b) => (currentRound % 2 === 1) ? b.number - a.number : a.number - b.number); // 其他模式採預設排序(與 U 相同)。 
        }

        return same.concat(cross); // 最後把同分群放前,跨分群接在後,回傳候選清單。 
      }

      // 段落說明:backtrack 演算法:遞迴回溯配對,盡量滿足跨分數次數上限(maxCross)。 // 回溯配對核心(搜尋配對)
      function backtrack(remain, crossCounts = {}, maxCross, depth = 0) { // 定義 backtrack(remain, crossCounts, maxCross, depth)。
        if (remain.length === 0) return []; // 若已配完(沒有剩餘玩家),回傳空陣列表示成功基底。 
        const p = remain[0]; // 取出第一位要配對的玩家 p。 
        let candidates = getCandidates(p, remain.slice(1)); // 取得 p 的候選對手(在剩下的玩家中)。 
        if (depth === 0 && candidates.length) { // 若在最外層(depth 0)且有候選人,嘗試只使用 matchPoints 最大的候選人。
          const maxMP = Math.max(...candidates.map(q => q.matchPoints)); // 找出候選人中最高的 matchPoints。 
          candidates = candidates.filter(q => q.matchPoints === maxMP); // 只保留 matchPoints 等於 maxMP 的候選人。 
        }
        for (const q of candidates) { // 遍歷候選人 q
          const isCross = p.matchPoints !== q.matchPoints; // 判斷 p 與 q 是否為跨分配對。 
          const prev = crossCounts[p.matchPoints] || 0; // 取得 p 這個分數在 crossCounts 的目前計數(預設 0)。 
          const incr = isCross && depth > 0 ? 1 : 0; // 若是跨分且 depth > 0,才算入 incr,外層配對不算(或依邏輯設計)。 
          if (prev + incr > maxCross) continue; // 若超過允許的跨分上限,跳過此候選。 
          const nextCross = { ...crossCounts, [p.matchPoints]: prev + incr }; // 建立下一層的 crossCounts 複本並更新。 
          const nextRemain = remain.filter(r => r !== p && r !== q); // 從 remain 移除 p 與 q,產生 nextRemain。 
          const rest = backtrack(nextRemain, nextCross, maxCross, depth + 1); // 對剩下的人遞迴呼叫 backtrack。 
          if (rest) { // 若 rest 為非 null(表示成功找到一組配對)
            return [{ player1: p, player2: q, result: null, bye: false, previousScore1: p.matchPoints, previousScore2: q.matchPoints }, ...rest]; // 回傳包含當前配對加上剩餘配對。 
          }
        }
        return null; // 若無候選或無成功配對,回傳 null 表示失敗路徑。 
      }

      // 段落說明:safeMicroAdjust:在初步配對後做小幅調整以降低 prior 差異與避免重複對戰、輪空偏差等。 // 微調函式(調整跨分/prior/避免重複)
      function safeMicroAdjust(matches, roundNum) { // 定義 safeMicroAdjust(matches, roundNum):針對 matches 做小幅調整,回傳調整後的 matches。
        const ms = matches.map(m => m ? Object.assign({}, m) : m); // 建立 matches 的淺複本陣列(避免直接改動原物件參考)。 
        const prior = {}; // prior 用於記錄到上一輪為止每位玩家的「贏/造成跨分」次數(或類似)。 
        players.forEach(p => prior[p.id] = 0); // 初始化 prior,每位玩家預設 0。 
        const upto = Math.max(0, Math.min(rounds.length, roundNum - 1)); // 計算要納入 prior 的輪次上限(到上輪為止)。 
        for (let r = 0; r < upto; r++) { // 遍歷先前輪次以計算 prior。
          const rd = rounds[r]; // 取得第 r 輪的記錄。 
          if (!rd || !Array.isArray(rd.matches)) continue; // 若該輪資料不存在或 matches 不是陣列,跳過。 
          rd.matches.forEach(m => { // 遍歷該輪每場比賽
            if (!m) return; // 若 match 為 null/undefined,跳過。 
            if (m.bye) { // 若該 match 為 bye
              if (m.player1) prior[m.player1.id] = (prior[m.player1.id] || 0) + 1; // 輪空視為 prior 增加一次(依系統定義)。 
              return; // 處理完 bye 後跳出該 match 的處理。 
            }
            const s1 = (typeof m.previousScore1 !== 'undefined') ? Number(m.previousScore1 || 0) : 0; // 取 previousScore1(若存在)否則 0。 
            const s2 = (typeof m.previousScore2 !== 'undefined') ? Number(m.previousScore2 || 0) : 0; // 取 previousScore2(若存在)否則 0。 
            if (s1 !== s2) { // 如果雙方分數不同(即跨分發生)
              if (m.player1) prior[m.player1.id] = (prior[m.player1.id] || 0) + 1; // player1 的 prior +1。 
              if (m.player2) prior[m.player2.id] = (prior[m.player2.id] || 0) + 1; // player2 的 prior +1。 
            }
          });
        }

        // 段落說明:isCrossInMatch:判斷指定 match 中某位玩家是否為跨分(用 match 的 previousScore 若有則比 previousScore,否則比 matchPoints)。 // 判斷 match 是否為 cross(針對特定 player)
        function isCrossInMatch(match, playerId) { // 定義 isCrossInMatch(match, playerId)。
          if (!match) return false; // 若 match 不存在回傳 false。 
          if (match.bye) return match.player1 && match.player1.id === playerId; // 若是 bye,且 player1 是該玩家則回傳 true(輪空視為特殊情況)。 
          const s1 = (typeof match.previousScore1 !== 'undefined') ? Number(match.previousScore1 || 0) : (match.player1 ? Number(match.player1.matchPoints || 0) : 0);
          // 取 player1 的 previousScore1 或 matchPoints。 
          const s2 = (typeof match.previousScore2 !== 'undefined') ? Number(match.previousScore2 || 0) : (match.player2 ? Number(match.player2.matchPoints || 0) : 0);
          // 取 player2 的 previousScore2 或 matchPoints。 
          if (s1 !== s2) { // 若雙方分數不同,表示為跨分
            if (match.player1 && match.player1.id === playerId) return true; // 若 playerId 是 player1 則回 true。 
            if (match.player2 && match.player2.id === playerId) return true; // 若 playerId 是 player2 則回 true。 
          }
          return false; // 否則回傳 false。 
        }

        // 段落說明:havePlayedBefore:檢查兩位玩家是否已經在歷史中對過(從 players 的 opponents 屬性判斷)。 // 過去是否對過
        function havePlayedBefore(aId, bId) { // 定義 havePlayedBefore(aId,bId)。
          if (!aId || !bId) return false; // 若任一 id 不存在,回傳 false。 
          const a = players.find(p => p.id === aId); // 找到玩家 a 的完整物件。 
          return a && Array.isArray(a.opponents) && a.opponents.includes(bId); // 若 a.opponents 包含 bId 則回傳 true。 
        }

        const nonByeIdx = ms.map((m, idx) => ({ m, idx })).filter(x => x.m).map(x => x.idx); // 取得所有非空 match 的索引陣列。 
        const playerMatchIdx = {}; // 建立玩家 id -> match index 的 map(會在下方填入)。 
        ms.forEach((m, idx) => { // 填充 playerMatchIdx
          if (!m) return; // 跳過空值。 
          if (m.bye) { // 若 match 為 bye
            if (m.player1) playerMatchIdx[m.player1.id] = idx; // 輪空的玩家記錄其 match index。 
          } else {
            if (m.player1) playerMatchIdx[m.player1.id] = idx; // 記錄 player1 的 match index。 
            if (m.player2) playerMatchIdx[m.player2.id] = idx; // 記錄 player2 的 match index。 
          }
        });

        const crossPlayers = []; // 會收集本輪為跨分的玩家 id 陣列。 
        const nonCrossPlayers = []; // 會收集本輪不是跨分的玩家 id 陣列。 
        nonByeIdx.forEach(idx => { // 對每個非空的 match index 檢查
          const m = ms[idx]; // 取得 match 物件。 
          const p1 = m.player1 && m.player1.id; // 取得 player1 的 id(若存在)。 
          const p2 = m.player2 && m.player2.id; // 取得 player2 的 id(若存在)。 
          if (p1) {
            if (isCrossInMatch(m, p1)) crossPlayers.push(p1); else nonCrossPlayers.push(p1); // 根據 isCrossInMatch 判斷並推入對應陣列。 
          }
          if (p2) {
            if (isCrossInMatch(m, p2)) crossPlayers.push(p2); else nonCrossPlayers.push(p2); // 同上,針對 player2。 
          }
        });

        crossPlayers.sort((a, b) => (prior[b] || 0) - (prior[a] || 0)); // 把 crossPlayers 依 prior 從高到低排序(優先處理 prior 高者)。 
        nonCrossPlayers.sort((a, b) => (prior[a] || 0) - (prior[b] || 0)); // 把 nonCrossPlayers 依 prior 從低到高排序(優先處理 prior 低者)。 

        // 段落說明:otherPlayerId / prevScoreOf 的輔助函式:分別取出某場比賽中另一位對手的 id,以及取得某玩家在某 match 中的 previous score(或 matchPoints 作 fallback)。 // 取出對手 id 及 previousScore 的輔助
        function otherPlayerId(match, pid) { // 定義 otherPlayerId(match, pid):回傳該 match 中與 pid 的對手 id,若無或 bye 則回 null。
          if (!match || match.bye) return null; // match 不存在或為 bye,回傳 null。 
          if (match.player1 && match.player1.id === pid) return match.player2 ? match.player2.id : null; // 若 pid 是 player1,回傳 player2 的 id(若存在)。 
          if (match.player2 && match.player2.id === pid) return match.player1 ? match.player1.id : null; // 若 pid 是 player2,回傳 player1 的 id(若存在)。 
          return null; // 若都不是,回傳 null(保守處理)。 
        }

        function prevScoreOf(id, match) { // 定義 prevScoreOf(id, match):取得 id 在 match 中的 previous score,若無則回傳玩家的 matchPoints 或 0。
          if (!id) return 0; // 若 id 不存在,回傳 0。 
          if (!match) {
            const p = players.find(pp => pp.id === id); // 若沒有 match,回到 players 陣列找該玩家
            return p ? Number(p.matchPoints || 0) : 0; // 回傳該玩家 matchPoints 或 0。 
          }
          if (match.player1 && match.player1.id === id && typeof match.previousScore1 !== 'undefined') return Number(match.previousScore1 || 0); // 若 match.player1 且有 previousScore1,回傳其值。 
          if (match.player2 && match.player2.id === id && typeof match.previousScore2 !== 'undefined') return Number(match.previousScore2 || 0); // 若 match.player2 且有 previousScore2,回傳其值。 
          const p = players.find(pp => pp.id === id); // 否則 fallback 到 players 找 matchPoints。 
          return p ? Number(p.matchPoints || 0) : 0; // 回傳 matchPoints 或 0。 
        }

        for (const cpId of crossPlayers) { // 對每個被標為 cross 的玩家嘗試進行 swap(把 cross 的玩家與非 cross 的玩家互換對手)
          const cpIdx = playerMatchIdx[cpId]; // 取得該 cross 玩家所在的 match index。 
          if (typeof cpIdx === 'undefined') continue; // 若沒有紀錄則跳過。 
          const mA = ms[cpIdx]; // 取得該 match 物件 mA。 
          if (!mA) continue; // 若 match 不存在跳過。 

          let didSwap = false; // 標記是否做過交換。 
          if (mA && !mA.bye) { // 若 mA 存在且不是 bye,會對 nonCrossPlayers 做依號碼距離排序以優先匹配靠近號碼者。
            const cpNumber = Number(((players.find(p => p.id === cpId) || {}).number) || 0); // 取得 cp 的編號(number)。 
            nonCrossPlayers.sort((a, b) => { // 根據編號距離 cpNumber 的絕對差排序,差小者優先;若相同,再按編號小者優先。
              const na = Math.abs((Number(((players.find(p => p.id === a) || {}).number) || 0)) - cpNumber); // 計算 a 與 cp 的編號差值絕對值。 
              const nb = Math.abs((Number(((players.find(p => p.id === b) || {}).number) || 0)) - cpNumber); // 計算 b 與 cp 的編號差值絕對值。 
              return na !== nb ? na - nb : (Number(((players.find(p => p.id === a) || {}).number) || 0) - Number(((players.find(p => p.id === b) || {}).number) || 0)); // 差小者優先,否則按編號比較。 
            });
          }

          for (let k = 0; k < nonCrossPlayers.length; k++) { // 遍歷 nonCrossPlayers,嘗試與 cp 配對對換對手
            const ncId = nonCrossPlayers[k]; // non-cross 玩家 id。 
            const ncIdx = playerMatchIdx[ncId]; // non-cross 玩家所在的 match index。 
            if (typeof ncIdx === 'undefined') continue; // 若沒有紀錄跳過。 
            if (ncIdx === cpIdx) continue; // 若兩位在同一場比賽(不應互換),跳過。 
            const mB = ms[ncIdx]; // 取得非跨分玩家所在的 match 物件 mB。 
            if (!mB) continue; // 若 mB 不存在,跳過。 

            const oppA = otherPlayerId(mA, cpId); // 取出 mA 中 cp 的對手 id(oppA)。 
            const oppB = otherPlayerId(mB, ncId); // 取出 mB 中 nc 的對手 id(oppB)。 

            if (!((prior[ncId] || 0) < (prior[cpId] || 0))) continue; // 若 nc 的 prior 不小於 cp 的 prior,跳過(只在 prior 較小時考慮)。 
            if ((oppB !== null && oppB === cpId) || (oppA !== null && oppA === ncId)) continue; // 若會造成彼此互為對手的情況,跳過。 
            if (oppB && havePlayedBefore(cpId, oppB)) continue; // 若 cp 已經和 oppB 對過,跳過。 
            if (oppA && havePlayedBefore(ncId, oppA)) continue; // 若 nc 已經和 oppA 對過,跳過。 

            const allBefore = new Set(); // 建立集合 allBefore 用來紀錄調整前所有出場玩家 id(去重)。
            ms.forEach(mm => { // 遍歷現在的 matches 把所有玩家 id 加入 allBefore
              if (!mm) return; // 跳過空值。 
              if (mm.bye) {
                if (mm.player1) allBefore.add(mm.player1.id); // bye 的 player1 加入集合。 
              } else {
                if (mm.player1) allBefore.add(mm.player1.id); // 非 bye 的 player1 加入集合。 
                if (mm.player2) allBefore.add(mm.player2.id); // 非 bye 的 player2 加入集合。 
              }
            });

            const tmpAssign = new Map(); // tmpAssign 用以模擬交換後每台的選手分配,key = matchIdx, value = [playerA, playerB]
            ms.forEach((mm, idx) => { // 先把現有分配複製到 tmpAssign
              if (!mm) return; // 跳過空值。 
              if (mm.bye) {
                tmpAssign.set(idx, [mm.player1 ? mm.player1.id : null, null]); // bye 的情況第二位為 null。 
              } else {
                tmpAssign.set(idx, [mm.player1 ? mm.player1.id : null, mm.player2 ? mm.player2.id : null]); // 一般 match 儲存兩位 id(可能為 null)。 
              }
            });

            function placeInCopy(matchIdx, oldId, newOppId) { // placeInCopy:在 tmpAssign 的某場中把 oldId 的對手替換為 newOppId(模擬)
              const arr = tmpAssign.get(matchIdx).slice(); // 取出陣列並複製
              if (arr[0] === oldId) {
                arr[1] = newOppId; // 若 oldId 在位置 0,將位置 1 指定為 newOppId。 
              } else if (arr[1] === oldId) {
                arr[0] = newOppId; // 若 oldId 在位置 1,將位置 0 指定為 newOppId。 
              } else {
                arr[1] = newOppId; // 保守處理:若找不到 oldId,預設把 newOppId 放到位置 1。 
              }
              tmpAssign.set(matchIdx, arr); // 更新 tmpAssign。 
            }
            placeInCopy(cpIdx, cpId, oppB); // 在 tmpAssign 模擬替換 cp 的對手為 oppB。 
            placeInCopy(ncIdx, ncId, oppA); // 在 tmpAssign 模擬替換 nc 的對手為 oppA。 

            const allAfter = new Set(); // allAfter 用來紀錄交換後的所有出場玩家 id
            for (const [idx, arr] of tmpAssign.entries()) { // 把 tmpAssign 的每個位置所含的 id 加入集合
              const a = arr[0], b = arr[1]; // 取出雙方 id
              if (a) allAfter.add(a); // 若 a 存在則加入
              if (b) allAfter.add(b); // 若 b 存在則加入
            }

            if (allAfter.size !== allBefore.size) continue; // 若交換後集合大小不一致,表示有人被重複或遺漏,跳過
            let identical = true; // 檢查所有 id 是否一致(集合相等)
            for (const id of allBefore) if (!allAfter.has(id)) { identical = false; break; } // 若有任一 id 不存在於 allAfter,標示非相等
            if (!identical) continue; // 若不一致則跳過

            const cpWillBeCross = (() => { // 決定 cp 交換後是否仍為 cross(透過 previousScore / matchPoints 判斷)
              if (oppB == null) return true; // 若 oppB 為 null(對手不存在)則視為 cross(bye)
              const scp = prevScoreOf(cpId, mA); // 取 cp 原先的 previousScore(或 matchPoints)
              const soppB = prevScoreOf(oppB, mB); // 取 oppB 在 mB 的 previousScore(或 matchPoints)
              return scp !== soppB; // 若不等則交換後為 cross
            })();
            const ncWillBeCross = (() => { // 決定 nc 交換後是否為 cross
              if (oppA == null) return true; // 若 oppA 為 null,視為 cross(bye)
              const snc = prevScoreOf(ncId, mB); // 取 nc 原先的 previousScore
              const soppA = prevScoreOf(oppA, mA); // 取 oppA 的 previousScore
              return snc !== soppA; // 若不等則交換後為 cross
            })();

            if (!isCrossInMatch(mA, cpId)) continue; // 若原本 mA 並非 cross(對 cp),跳過(只處理原本為 cross 的情況)
            if (cpWillBeCross) continue; // 若交換後 cp 仍為 cross,跳過(希望降低 cross)
            if (!ncWillBeCross) continue; // 若交換後 nc 也不是 cross(則無意義或破壞目標),跳過

            function setOpponent(matchObj, pid, newOppId) { // 實際在 matchObj 上設定新的對手物件(依 id 轉成 player 物件)
              const newOppObj = newOppId ? players.find(pp => pp.id === newOppId) : null; // 找到 newOpp 的玩家物件或 null
              if (matchObj.player1 && matchObj.player1.id === pid) {
                matchObj.player2 = newOppObj; // 若 pid 在 player1,替換 player2
              } else if (matchObj.player2 && matchObj.player2.id === pid) {
                matchObj.player1 = newOppObj; // 若 pid 在 player2,替換 player1
              } else {
                matchObj.player1 = players.find(pp => pp.id === pid); // 若都找不到,保守將 pid 放到 player1
                matchObj.player2 = newOppObj; // 並將 newOpp 放到 player2
              }
            }

            setOpponent(mA, cpId, oppB); // 在 mA 中把 cp 的對手設定為 oppB
            setOpponent(mB, ncId, oppA); // 在 mB 中把 nc 的對手設定為 oppA

            [mA, mB].forEach(mm => { // 更新 mA 與 mB 的 bye、result、previousScore 欄位
              if (!mm.player2) {
                mm.bye = true; // 若第二位不存在,設為 bye
                mm.result = mm.result || "2:0"; // 若 result 尚未存在,給預設結果 "2:0"
                if (mm.player1) mm.previousScore1 = Number(mm.player1.matchPoints || 0); // 設定 previousScore1 為該玩家的 matchPoints
                delete mm.previousScore2; // 刪除 previousScore2(bye 的情況)
              } else {
                mm.bye = false; // 有雙方玩家則非 bye
                mm.result = null; // 清除 result(等待實際結果)
                if (mm.player1) mm.previousScore1 = Number(mm.player1.matchPoints || 0); // 設 previousScore1
                if (mm.player2) mm.previousScore2 = Number(mm.player2.matchPoints || 0); // 設 previousScore2
              }
            });

            playerMatchIdx[cpId] = cpIdx; // 更新 playerMatchIdx 對應
            playerMatchIdx[ncId] = ncIdx; // 更新 playerMatchIdx 對應
            if (oppB) playerMatchIdx[oppB] = cpIdx; // 若 oppB 存在更新對應
            if (oppA) playerMatchIdx[oppA] = ncIdx; // 若 oppA 存在更新對應

            nonCrossPlayers.splice(k, 1); // 從 nonCrossPlayers 中移除已處理的 ncId

            didSwap = true; // 標記已交換
            break; // 跳出 nonCrossPlayers 的迴圈
          }
          if (didSwap) {
            continue; // 如果已交換,繼續處理下一個 crossPlayers
          }
        }
        return ms; // 回傳可能被修改過的 matches(ms)
      }

      // 段落說明:排輪空(bye)的處理邏輯:選擇輪空候選人、嘗試回溯生成剩餘配對,並用 safeMicroAdjust 微調配對使其合法且合理。 // 處理輪空(若需要)
      if (allowBye) { // 若允許 bye(玩家數為奇數)
        const byeCandidates = active.filter(p => !p.hadBye); // 只選擇尚未輪空過的候選人
        if (byeCandidates.length) { // 若存在候選人
          const minPts = Math.min(...byeCandidates.map(p => p.matchPoints)); // 找出候選人中 matchPoints 的最小值
          const lowestGroup = byeCandidates.filter(p => p.matchPoints === minPts); // 取出分數最低的群組
          let priSorted; // 優先排序後的候選順序

          if (pairingMode === 'U') { // U:編號大者先,但嘗試順序要從中間開始往外擴
            const sortedDesc = lowestGroup.slice().sort((a, b) => b.number - a.number); // 先做降序(編號大者先)
            const mid = Math.floor(sortedDesc.length / 2);
            priSorted = [];
            if (sortedDesc.length > 0) {
              priSorted.push(sortedDesc[mid]);
              for (let offset = 1; offset < sortedDesc.length; offset++) {
                const left = mid - offset;
                const right = mid + offset;
                if (left >= 0) priSorted.push(sortedDesc[left]);
                if (right < sortedDesc.length) priSorted.push(sortedDesc[right]);
              }
            }
          } else if (pairingMode === 'Z') {
            priSorted = lowestGroup.slice().sort((a, b) => {
              return (currentRound % 2 === 1) ? (b.number - a.number) : (a.number - b.number); // Z 模式有輪次奇偶差異(你原本寫法)
            });
          } else if (pairingMode === 'Z') {
            priSorted = lowestGroup.slice().sort((a, b) => {
              return (currentRound % 2 === 1) ? (b.number - a.number) : (a.number - b.number); // Z 模式有輪次奇偶差異
            });
          }
          const others = byeCandidates.filter(p => !priSorted.includes(p))
            .slice()
            .sort((a, b) => a.matchPoints - b.matchPoints || a.number - b.number); // 其餘候選人按分數、編號排序

          const tryOrder = [...priSorted, ...others]; // 嘗試順序:先 priSorted,再 others
          let finalAdjusted = null; // 若找到可接受的方案會放在 finalAdjusted
          let finalBye = null; // 對應的 byePair

          for (const candidateBye of tryOrder) { // 依序嘗試每個候選輪空者
            const activeCopy = active.filter(p => p !== candidateBye); // 移除 candidateBye,生成 activeCopy 作為回溯配對的輸入
            activeCopy.sort((a, b) => { // 先把 activeCopy 排序(高分往前)
              if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints; // 先比較 matchPoints
              if (['Z', 'U'].includes(pairingMode)) {
                return (currentRound % 2 === 1) ? a.number - b.number : b.number - a.number; // Z/U 模式提供額外排序規則
              }
              return 0; // 否則視為相等
            });

            const defaultMaxCross = (activeCopy.length < 16 && currentRound >= 6) ? 2 : 1; // 根據規則決定預設的 maxCross
            const fallbackMaxCross = defaultMaxCross + 1; // fallback(寬鬆一級)的 maxCross
            const pairings =
              backtrack(activeCopy, {}, defaultMaxCross, 0) // 嘗試使用預設 maxCross 回溯配對
              || backtrack(activeCopy, {}, fallbackMaxCross, 0) // 若失敗則嘗試 fallback
              || backtrack(activeCopy, {}, fallbackMaxCross + 1, 0) // 再寬鬆一級
              || backtrack(activeCopy, {}, fallbackMaxCross + 2, 0) // 再寬鬆一級
              || []; // 若都失敗回傳空陣列
            if (!pairings || pairings.length === 0) {
              continue; // 若沒配對結果則繼續下一個候選 bye
            }

            const candidateByePair = {
              player1: candidateBye,
              player2: null,
              result: "2:0",
              bye: true,
              previousScore1: Number(candidateBye.matchPoints || 0)
            }; // 建立該 candidate 的 byePair 物件
            const raw = [candidateByePair, ...pairings]; // raw 為包含 byePair 與其餘配對的初始陣列
            const adjusted = safeMicroAdjust(raw, currentRound); // 把 raw 交給 safeMicroAdjust 做微調
            const nonByeMatches = adjusted.filter(m => m && !m.bye); // 取得非輪空的比賽數量
            if (nonByeMatches.length === (activeCopy.length / 2)) { // 若非輪空場次數量等於預期(所有人皆配對)
              finalAdjusted = adjusted; // 接受此 adjusted
              finalBye = candidateByePair; // 並記錄對應的 byePair
              break; // 找到可接受的方案後跳出迴圈
            }
          }

          if (finalAdjusted) { // 若找到 finalAdjusted
            byePair = finalBye; // 設定 byePair
            active = active.filter(p => p !== finalBye.player1); // 將 bye 的玩家從 active 中移除
            var precomputedAdjusted = finalAdjusted; // 將 precomputedAdjusted 設為 finalAdjusted 以便後續直接使用
          } else {
            const pickIndex = (pairingMode === 'U') ? Math.floor(priSorted.length / 2) : (priSorted.length - 1); // 若沒有可用方案,依策略選擇一位作為輪空
            const byePlayer = priSorted[pickIndex] || priSorted[0]; // 選取預設的 byePlayer
            if (byePlayer) {
              byePair = {
                player1: byePlayer,
                player2: null,
                result: "2:0",
                bye: true,
                previousScore1: Number(byePlayer.matchPoints || 0)
              }; // 建立 byePair
              active = active.filter(p => p !== byePlayer); // 將其從 active 中移除
            }
          }
        }
      }

      let adjusted; // 段落說明:接下來使用已預先計算的 adjusted(若有),或使用回溯配對產生一組 raw,再用 safeMicroAdjust 做最終微調。 // 生成最終 adjusted
      if (typeof precomputedAdjusted !== 'undefined') { // 若 precomputedAdjusted 存在(先前輪空嘗試成功)
        adjusted = precomputedAdjusted; // 直接使用
      } else {
        active.sort((a, b) => { // 否則先把 active 排序(高分在前,並依 pairingMode 做 tie-break)
          if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints; // 先比分數
          if (['Z', 'U'].includes(pairingMode)) {
            return (currentRound % 2 === 1) ? a.number - b.number : b.number - a.number; // Z/U 模式的排序
          }
          return 0; // 否則不改變相對順序
        });

        const defaultMaxCross = (active.length < 16 && currentRound >= 6) ? 2 : 1; // 設定 defaultMaxCross(同上)
        const fallbackMaxCross = defaultMaxCross + 1; // fallback 設定

        const pairings = backtrack(active, {}, defaultMaxCross, 0) // 嘗試回溯配對多個容忍值
          || backtrack(active, {}, fallbackMaxCross, 0)
          || backtrack(active, {}, fallbackMaxCross + 1, 0)
          || backtrack(active, {}, fallbackMaxCross + 2, 0)
          || [];

        const raw = byePair ? [byePair, ...pairings] : pairings; // raw 為含 byePair 的配對清單(若有)
        adjusted = safeMicroAdjust(raw, currentRound); // 對 raw 做 micro adjust 並得到 adjusted
      }

      //
      // ===== 在此處新增:三向循環(3-cycle / chain=2)嘗試 =====
      // 條件:
      //  - 同分群 >= 4 人
      //  - 分佈在 >= 3 台(不同 match index)
      //  - 到此輪的初步對陣 prior 的 max - min >= 2
      //  - 嘗試三人循環:pa->ob, pb->oc, pc->oa
      //  - 只有在群內 projected max prior 降低時才接受
      //

      // 先寫輔助函式:計算到上輪的 prior(與 safeMicroAdjust 一樣)
      function computePriorsUpToPrevRound() { // 定義 computePriorsUpToPrevRound:計算到上輪為止每位玩家的 prior 值
        const prior = {}; // prior map 初始化
        players.forEach(p => prior[p.id] = 0); // 每個玩家初始化為 0
        const upto = Math.max(0, Math.min(rounds.length, currentRound - 1)); // 計算要納入 prior 的輪次
        for (let r = 0; r < upto; r++) { // 遍歷
          const rd = rounds[r]; // 取出每輪
          if (!rd || !Array.isArray(rd.matches)) continue; // 若資料無效則跳過
          rd.matches.forEach(m => { // 逐場處理
            if (!m) return; // 跳過空值
            if (m.bye) { // bye 的處理
              if (m.player1) prior[m.player1.id] = (prior[m.player1.id] || 0) + 1; // bye 增 prior
              return; // 跳下一場
            }
            const s1 = (typeof m.previousScore1 !== 'undefined') ? Number(m.previousScore1 || 0) : 0; // 讀 previousScore1
            const s2 = (typeof m.previousScore2 !== 'undefined') ? Number(m.previousScore2 || 0) : 0; // 讀 previousScore2
            if (s1 !== s2) { // 若有分差
              if (m.player1) prior[m.player1.id] = (prior[m.player1.id] || 0) + 1; // 皆 +1
              if (m.player2) prior[m.player2.id] = (prior[m.player2.id] || 0) + 1; // 皆 +1
            }
          });
        }
        return prior; // 回傳 prior map
      }

      // 建立 playerId -> { matchIndex, isPlayer1, opp, matchRef } map(方便操作)
      function buildPlayerMatchMap(matches) { // 定義 buildPlayerMatchMap(matches):依照 matches 建立快速查詢 map
        const map = new Map(); // 使用 Map 儲存
        matches.forEach((m, idx) => { // 遍歷 matches
          if (!m) return; // 跳過空
          if (m.bye) {
            if (m.player1) map.set(m.player1.id, { matchIndex: idx, isPlayer1: true, opp: null, match: m }); // bye 的記錄
            return; // 跳下一個 match
          }
          if (m.player1) map.set(m.player1.id, { matchIndex: idx, isPlayer1: true, opp: m.player2 || null, match: m }); // 記錄 player1
          if (m.player2) map.set(m.player2.id, { matchIndex: idx, isPlayer1: false, opp: m.player1 || null, match: m }); // 記錄 player2
        });
        return map; // 回傳 map
      }

      function havePlayedBeforeByIds(aId, bId) { // 定義 havePlayedBeforeByIds:與之前的 havePlayedBefore 類似但專門用 id 參數
        if (!aId || !bId) return false; // 若任一 id 不存在回傳 false
        const a = players.find(p => p.id === aId); // 找到 a
        return a && Array.isArray(a.opponents) && a.opponents.includes(bId); // 檢查 a.opponents 是否包含 bId
      }

      // 模擬某對手會否造成本輪 prior 增加(使用 previousScore / matchPoints 判斷)
      function prevScoreOfIdInMatch(id, matchObj) { // 定義 prevScoreOfIdInMatch:類似 prevScoreOf,但命名略不同
        if (!id) return 0; // 若 id 不存在回 0
        if (!matchObj) {
          const p = players.find(pp => pp.id === id); // 沒有 match 尋找 player
          return p ? Number(p.matchPoints || 0) : 0; // 回傳 matchPoints 或 0
        }
        if (matchObj.player1 && matchObj.player1.id === id && typeof matchObj.previousScore1 !== 'undefined') return Number(matchObj.previousScore1 || 0); // 若為 player1 且有 previousScore1
        if (matchObj.player2 && matchObj.player2.id === id && typeof matchObj.previousScore2 !== 'undefined') return Number(matchObj.previousScore2 || 0); // 若為 player2 且有 previousScore2
        const p = players.find(pp => pp.id === id); // fallback
        return p ? Number(p.matchPoints || 0) : 0; // 回傳 matchPoints 或 0
      }

      // 計算 projectedPrior:priorToPrevRound + (本輪是否為 cross ? 1 : 0)
      function projectedPriorWithOpponentUsingScores(priorMap, playerObj, oppObj) { // 定義 projectedPriorWithOpponentUsingScores:估計若與某對手配對時該玩家的 projected prior
        const before = priorMap[playerObj.id] || 0; // prior 基底
        if (!oppObj) return before; // 若無對手(bye)直接回 prior 基底
        const sPlayer = Number(playerObj.matchPoints || 0); // 取 player 的分數
        const sOpp = Number(oppObj.matchPoints || 0); // 取對手的分數
        // 若你想用 previousScoreOf 邏輯(來處理 precomputed previousScoreX)可替換這裡
        const inc = (sPlayer !== sOpp) ? 1 : 0; // 若分數不同則本輪會造成 prior +1
        return before + inc; // 回傳 projected prior
      }

      // 段落說明:tryThreeCycleForGroup:對某個分數群嘗試所有三人選組,模擬三向循環(pa->ob, pb->oc, pc->oa),若能降低群內 projected max prior 則套用該交換。 // 三向循環嘗試主體函式
      function tryThreeCycleForGroup(scoreGroupPlayers, matches) { // 定義 tryThreeCycleForGroup(scoreGroupPlayers, matches)
        if (!Array.isArray(scoreGroupPlayers) || scoreGroupPlayers.length < 4) return false; // 若參數無效或人數少於 4,直接返回 false

        const priorMap = computePriorsUpToPrevRound(); // 計算到上輪為止的 priorMap
        const pmap = buildPlayerMatchMap(matches); // 建立本輪 matches 的 player->match map

        // 檢查分佈台數
        const tables = new Set(); // 建立 set 以確認分佈在多少台
        scoreGroupPlayers.forEach(p => {
          const mm = pmap.get(p.id); // 取得該玩家在 matches 的配置
          if (mm) tables.add(mm.matchIndex); // 若存在則加入 matchIndex
        });
        if (tables.size < 3) return false; // 若分佈台數少於 3 台則不嘗試

        // 原始 projected prior(用目前 match 的對手模擬)
        const originalProjected = scoreGroupPlayers.map(p => {
          const mm = pmap.get(p.id); // 取得該玩家的 match map
          const opp = mm ? mm.opp : null; // 取得原先對手
          return (p && opp) ? projectedPriorWithOpponentUsingScores(priorMap, p, opp) : projectedPriorWithOpponentUsingScores(priorMap, p, null); // 計算 projected prior
        });
        const originalMax = Math.max.apply(null, originalProjected); // 計算原始的 max projected prior

        // 遍歷 triplet
        for (let a = 0; a < scoreGroupPlayers.length - 2; a++) { // 三層迴圈選出所有 triplet(a,b,c)
          for (let b = a + 1; b < scoreGroupPlayers.length - 1; b++) {
            for (let c = b + 1; c < scoreGroupPlayers.length; c++) {
              const pa = scoreGroupPlayers[a], pb = scoreGroupPlayers[b], pc = scoreGroupPlayers[c]; // 取出三位玩家
              const ma = pmap.get(pa.id), mb = pmap.get(pb.id), mc = pmap.get(pc.id); // 取得他們在 matches 中的 match 記錄
              if (!ma || !mb || !mc) continue; // 若任一不存在則跳過
              const oa = ma.opp, ob = mb.opp, oc = mc.opp; // 取得原本的對手
              if (!oa || !ob || !oc) continue; // skip 若有輪空(若要包含輪空可修改)

              // 檢查新配對是否曾對過(保留 havePlayedBefore)
              if (havePlayedBeforeByIds(pa.id, ob.id)) continue; // 若 pa 曾與 ob 對過則跳過
              if (havePlayedBeforeByIds(pb.id, oc.id)) continue; // 若 pb 曾與 oc 對過則跳過
              if (havePlayedBeforeByIds(pc.id, oa.id)) continue; // 若 pc 曾與 oa 對過則跳過

              // 防止把同一人配到同一 match 裡(1:1 原則)
              if (ob.id === pa.id || ob.id === pb.id || ob.id === pc.id) continue; // 若 ob 指向三人其中一人,跳過
              if (oc.id === pa.id || oc.id === pb.id || oc.id === pc.id) continue; // 同上
              if (oa.id === pa.id || oa.id === pb.id || oa.id === pc.id) continue; // 同上

              // 模擬交換後的 projected prior(只有這三人改變)
              const p_pa_new = projectedPriorWithOpponentUsingScores(priorMap, pa, ob); // pa 新的 projected prior(配到 ob)
              const p_pb_new = projectedPriorWithOpponentUsingScores(priorMap, pb, oc); // pb 新的 projected prior(配到 oc)
              const p_pc_new = projectedPriorWithOpponentUsingScores(priorMap, pc, oa); // pc 新的 projected prior(配到 oa)

              const newProjectedArray = scoreGroupPlayers.map(p => { // 建立新的 projected 陣列(只替換三人的值)
                if (p.id === pa.id) return p_pa_new; // 替換 pa
                if (p.id === pb.id) return p_pb_new; // 替換 pb
                if (p.id === pc.id) return p_pc_new; // 替換 pc
                const mm = pmap.get(p.id); // 其餘玩家保持原狀
                return mm && mm.opp ? projectedPriorWithOpponentUsingScores(priorMap, p, mm.opp) : projectedPriorWithOpponentUsingScores(priorMap, p, null); // 計算原狀 projected
              });

              const newMax = Math.max.apply(null, newProjectedArray); // 計算交換後的群內 max projected prior

              // 接受條件:群內 max prior 要降低
              if (newMax < originalMax) { // 若降低則套用交換
                // 實際在 matches 上套用:pa -> ob, pb -> oc, pc -> oa
                const matchA = ma.match, matchB = mb.match, matchC = mc.match; // 取得三個 match 物件

                function replaceOpponent(matchObj, currentPlayerId, newOppObj) { // replaceOpponent:在 matchObj 上將 currentPlayerId 的對手替換為 newOppObj(物件)
                  if (!matchObj) return; // 若 matchObj 不存在則跳過
                  // 若 currentPlayerId 在 player1,則替換 player2;若在 player2 則替換 player1
                  if (matchObj.player1 && matchObj.player1.id === currentPlayerId) {
                    matchObj.player2 = newOppObj; // 替換 player2
                  } else if (matchObj.player2 && matchObj.player2.id === currentPlayerId) {
                    matchObj.player1 = newOppObj; // 替換 player1
                  } else {
                    // 保守處理:若找不到 currentPlayerId,直接嘗試填滿空位
                    if (!matchObj.player1) matchObj.player1 = players.find(pp => pp.id === currentPlayerId); // 若 player1 空就填 currentPlayer
                    if (!matchObj.player2) matchObj.player2 = newOppObj; // 若 player2 空就填 newOpp
                  }
                }

                replaceOpponent(matchA, pa.id, ob); // 在 matchA 上執行 pa -> ob
                replaceOpponent(matchB, pb.id, oc); // 在 matchB 上執行 pb -> oc
                replaceOpponent(matchC, pc.id, oa); // 在 matchC 上執行 pc -> oa

                // 更新每個 match 的 bye / previousScore / result 欄位
                [matchA, matchB, matchC].forEach(mm => {
                  if (!mm) return; // 若空則跳過
                  if (!mm.player2) {
                    mm.bye = true; // 若缺 second player 則設為 bye
                    mm.result = mm.result || "2:0"; // 設預設結果
                    if (mm.player1) mm.previousScore1 = Number(mm.player1.matchPoints || 0); // 設 previousScore1
                    delete mm.previousScore2; // 刪除 previousScore2
                  } else {
                    mm.bye = false; // 有雙方
                    mm.result = null; // 清除 result
                    if (mm.player1) mm.previousScore1 = Number(mm.player1.matchPoints || 0); // 設 previousScore1
                    if (mm.player2) mm.previousScore2 = Number(mm.player2.matchPoints || 0); // 設 previousScore2
                  }
                });

                // 成功應用 -> 直接返回 true(若要繼續嘗試更多改良可改成不 return)
                return true; // 套用交換並回傳 true 表示已修改
              }
            }
          }
        }
        return false; // 若未找到可降低群內 max prior 的三向循環,回傳 false
      }

      // 段落說明:根據 adjusted 建立以分數為 key 的群組,並對每個群組檢查是否符合觸發三向循環的條件;若符合即呼叫 tryThreeCycleForGroup。 // 以分數建立群組並觸發三向循環嘗試
      try {
        const scoreGroups = {}; // 初始化 scoreGroups map
        adjusted.forEach((m, idx) => { // 遍歷 adjusted 並把被配到的玩家加入對應分數群
          if (!m) return; // 跳過空
          if (m.bye) {
            if (m.player1) {
              const s = String(m.player1.matchPoints || 0); // 取得 player1 的分數字串
              scoreGroups[s] = scoreGroups[s] || []; // 建立分數群陣列(若不存在)
              if (!scoreGroups[s].some(x => x.id === m.player1.id)) scoreGroups[s].push(m.player1); // 若尚未加入就加入
            }
            return; // bye 處理完跳下一個 match
          }
          const p1 = m.player1, p2 = m.player2; // 取出雙方
          if (p1) {
            const s1 = String(p1.matchPoints || 0); // p1 分數字串
            scoreGroups[s1] = scoreGroups[s1] || []; // 建立或取得群
            if (!scoreGroups[s1].some(x => x.id === p1.id)) scoreGroups[s1].push(p1); // 加入 p1(避免重複)
          }
          if (p2) {
            const s2 = String(p2.matchPoints || 0); // p2 分數字串
            scoreGroups[s2] = scoreGroups[s2] || []; // 建立或取得群
            if (!scoreGroups[s2].some(x => x.id === p2.id)) scoreGroups[s2].push(p2); // 加入 p2(避免重複)
          }
        });

        // 對每個群組檢查條件並嘗試 3-cycle(成功會直接修改 adjusted)
        Object.keys(scoreGroups).forEach(scoreKey => {
          const grp = scoreGroups[scoreKey]; // 取出群組陣列
          if (grp.length >= 4) { // 若群內人數 >= 4 才考慮
            // 使用已產生的 adjusted(目前的初步配對)計算該群的 projected prior,再判斷是否觸發
            // buildPlayerMatchMap 與 projectedPriorWithOpponentUsingScores 已在函式上方定義
            const pmap_for_trigger = buildPlayerMatchMap(adjusted); // 以 current adjusted 作為基準建立 pmap
            const priorMap_for_trigger = computePriorsUpToPrevRound(); // 到上輪為止的 prior 作為基底

            // 計算該群每位的 projected prior(含本輪依 adjusted 的 cross 增量)
            const projectedPriors = grp.map(p => {
              const mm = pmap_for_trigger.get(p.id); // 取得該玩家在 adjusted 的對手
              const opp = mm ? mm.opp : null; // 取得 opp(若有)
              return projectedPriorWithOpponentUsingScores(priorMap_for_trigger, p, opp); // 計算 projected prior
            });

            const minProjected = Math.min.apply(null, projectedPriors); // 計算 min
            const maxProjected = Math.max.apply(null, projectedPriors); // 計算 max

            // 觸發條件:以「已產生的初步配對的 projected prior」的 max - min >= 2
            if ((maxProjected - minProjected) >= 2) { // 若差距 >= 2,則嘗試三向循環
              tryThreeCycleForGroup(grp, adjusted); // 嘗試三向循環(若成功會直接修改 adjusted)
            }

          }
        });
      } catch (err) {
        console.warn('three-cycle 嘗試時發生錯誤:', err); // 若三向循環流程出錯,輸出警告但不阻斷
      }

      //
      // ===== 結束三向循環嘗試 =====
      //

      // ====== 先依規則調整每場 match 的左右位置(含同分輪次奇偶規則與跨分高分在左) ======
      (function () { // 段落說明:這個立即函式用來統一處理 match 中「左右位置」與 previousScore、bye、result 的最終正規化(先同分群,再跨分)。
        if (!Array.isArray(adjusted)) return; // 若 adjusted 非陣列則直接返回

        // 先建立分數群:key = score (string),value = array of { idx, match }
        const sameScoreGroups = new Map(); // 建立 Map 用於收集同分 match(左右需根據號碼與輪次規則交換)
        adjusted.forEach((m, idx) => {
          if (!m) return; // 跳過空 match
          if (m.bye) return; // bye 不列入同分群處理(bye 維持原位)
          const p1 = m.player1;
          const p2 = m.player2;
          if (!p1 || !p2) return; // 若雙方任一缺失則略過(bye 情況已在上面處理)
          if (Number(p1.matchPoints || 0) === Number(p2.matchPoints || 0)) { // 若雙方同分
            const s = String(p1.matchPoints || 0); // 取得分數字串作為 key
            if (!sameScoreGroups.has(s)) sameScoreGroups.set(s, []); // 建立陣列
            sameScoreGroups.get(s).push({ idx, match: m }); // 把該 match 與其索引加入群
          }
        });

        // 先處理同分群(按 adjusted 原始順序,也就是 idx 小的視為先的台次)
        const isOddRound = (currentRound % 2 === 1); // 判斷本輪是否為奇數輪(奇數輪小號左)
        for (const [score, arr] of sameScoreGroups.entries()) { // 遍歷每個同分群
          // arr 內元素本來就是按 adjusted.forEach 的 idx 產生,維持台次順序
          for (const item of arr) { // 對該群內每個 match 逐一處理
            const m = item.match; // 取得 match 物件
            if (!m) continue; // 若不存在跳過
            // 若資料缺一邊,先用原有 bye 處理
            const p1 = m.player1 || null; // player1 或 null
            const p2 = m.player2 || null; // player2 或 null
            if (!p1 || !p2) { // 若缺一邊
              if (p1 && !p2) { // 若只有 p1 存在
                m.bye = true; // 設為 bye
                m.result = m.result || "2:0"; // 預設結果
                m.previousScore1 = Number(p1.matchPoints || 0); // 設 previousScore1
                delete m.previousScore2; // 刪除 previousScore2
              } else if (!p1 && p2) { // 若只有 p2 存在
                m.player1 = p2; // 把 p2 放到 player1
                m.player2 = null; // player2 設為 null
                m.bye = true; // 設為 bye
                m.result = m.result || "2:0"; // 預設結果
                m.previousScore1 = Number(m.player1.matchPoints || 0); // 設 previousScore1
                delete m.previousScore2; // 刪除 previousScore2
              }
              continue; // 處理完跳下一個 match
            }

            // 決定左右:單數輪小號左;雙數輪大號左
            const n1 = Number(p1.number || 0); // p1 編號
            const n2 = Number(p2.number || 0); // p2 編號
            // 若相同號碼(極少),保留原位
            if (n1 === n2) {
              // 確保 previousScore 存在
              m.previousScore1 = (typeof m.previousScore1 !== 'undefined') ? Number(m.previousScore1) : Number(p1.matchPoints || 0); // 設 previousScore1
              m.previousScore2 = (typeof m.previousScore2 !== 'undefined') ? Number(m.previousScore2) : Number(p2.matchPoints || 0); // 設 previousScore2
              m.bye = false; // 非 bye
              m.result = m.result || null; // 保留或清除 result
              continue; // 跳下一個 match
            }

            const shouldSmallOnLeft = isOddRound; // true 表示小號放左(奇數輪)
            const smallIsP1 = n1 < n2; // 判斷 p1 是否為小號
            const smallCurrentlyLeft = smallIsP1; // 若 p1 為小號則目前左邊為小號
            const needSwap = (shouldSmallOnLeft && !smallCurrentlyLeft) || (!shouldSmallOnLeft && smallCurrentlyLeft); // 判斷是否需要交換

            if (needSwap) { // 若需要交換左右
              // swap players
              const oldP1 = m.player1, oldP2 = m.player2; // 保存舊的左右
              const oldPS1 = (typeof m.previousScore1 !== 'undefined') ? m.previousScore1 : Number(oldP1.matchPoints || 0); // 保存原 previousScore1
              const oldPS2 = (typeof m.previousScore2 !== 'undefined') ? m.previousScore2 : Number(oldP2.matchPoints || 0); // 保存原 previousScore2

              m.player1 = oldP2; // 將左右交換
              m.player2 = oldP1; // 將左右交換

              // 更新 previousScore 與 bye/result
              m.previousScore1 = (typeof oldPS2 !== 'undefined') ? Number(oldPS2) : Number(m.player1.matchPoints || 0); // 更新 previousScore1 為原 player2 的 previousScore
              m.previousScore2 = (typeof oldPS1 !== 'undefined') ? Number(oldPS1) : Number(m.player2.matchPoints || 0); // 更新 previousScore2 為原 player1 的 previousScore

              if (!m.player2) {
                m.bye = true; // 若交換後沒有 player2 則設為 bye
                m.result = m.result || "2:0"; // 預設結果
                delete m.previousScore2; // 刪除 previousScore2
              } else {
                m.bye = false; // 否則非 bye
                m.result = m.result || null; // 清或保留 result
              }
            } else {
              // 不需交換,確保 previousScore 存在
              m.previousScore1 = (typeof m.previousScore1 !== 'undefined') ? Number(m.previousScore1) : Number(m.player1.matchPoints || 0); // 設 previousScore1
              m.previousScore2 = (typeof m.previousScore2 !== 'undefined') ? Number(m.previousScore2) : Number(m.player2.matchPoints || 0); // 設 previousScore2
              m.bye = false; // 非 bye
              m.result = m.result || null; // 保持或清除 result
            }
          }
        }

        // 再處理跨分(分數不同)的 match:高分放左、低分放右
        adjusted.forEach(m => {
          if (!m) return; // 跳過空
          if (m.bye) {
            if (m.player1) m.previousScore1 = Number(m.player1.matchPoints || 0); // bye 保證 previousScore1 存在
            m.result = m.result || "2:0"; // bye 預設結果
            return; // 跳下一個
          }
          const p1 = m.player1 || null; // p1 或 null
          const p2 = m.player2 || null; // p2 或 null
          if (!p1 || !p2) {
            if (p1 && !p2) {
              m.bye = true; // 若只有 p1 存在則設為 bye
              m.result = m.result || "2:0"; // 預設結果
              m.previousScore1 = Number(p1.matchPoints || 0); // 設 previousScore1
              delete m.previousScore2; // 刪除 previousScore2
            } else if (!p1 && p2) {
              m.player1 = p2; // 把 p2 放到 player1
              m.player2 = null; // player2 設為 null
              m.bye = true; // 設為 bye
              m.result = m.result || "2:0"; // 預設結果
              m.previousScore1 = Number(m.player1.matchPoints || 0); // 設 previousScore1
              delete m.previousScore2; // 刪除 previousScore2
            }
            return; // 處理完跳下一個
          }

          const s1 = Number(p1.matchPoints || 0); // 取得 p1 分數
          const s2 = Number(p2.matchPoints || 0); // 取得 p2 分數
          if (s1 !== s2) { // 若分數不同(跨分)
            // 高分在左,若左邊分數較小就交換
            if (s1 < s2) { // 若左邊分數較小,交換左右使高分在左
              const oldP1 = m.player1, oldP2 = m.player2; // 保存舊左右
              const oldPS1 = (typeof m.previousScore1 !== 'undefined') ? m.previousScore1 : Number(oldP1.matchPoints || 0); // 保存原 previousScore1
              const oldPS2 = (typeof m.previousScore2 !== 'undefined') ? m.previousScore2 : Number(oldP2.matchPoints || 0); // 保存原 previousScore2

              m.player1 = oldP2; // 交換左右(使高分移到 player1)
              m.player2 = oldP1; // 交換左右

              m.previousScore1 = (typeof oldPS2 !== 'undefined') ? Number(oldPS2) : Number(m.player1.matchPoints || 0); // 更新 previousScore1
              m.previousScore2 = (typeof oldPS1 !== 'undefined') ? Number(oldPS1) : Number(m.player2.matchPoints || 0); // 更新 previousScore2

              if (!m.player2) {
                m.bye = true; // 若交換後缺第二位則設為 bye
                m.result = m.result || "2:0"; // 預設結果
                delete m.previousScore2; // 刪除 previousScore2
              } else {
                m.bye = false; // 否則非 bye
                m.result = m.result || null; // 清或保留 result
              }
            } else {
              // s1 > s2,已是正確順序
              m.previousScore1 = (typeof m.previousScore1 !== 'undefined') ? Number(m.previousScore1) : Number(m.player1.matchPoints || 0); // 確保 previousScore1
              m.previousScore2 = (typeof m.previousScore2 !== 'undefined') ? Number(m.previousScore2) : Number(m.player2.matchPoints || 0); // 確保 previousScore2
              m.bye = false; // 非 bye
              m.result = m.result || null; // 保持或清除 result
            }
          }
        });
      })(); // 立即執行函式結束

      // ====== 之後再進行排序(把高總分排前、bye 放最後) ======
      adjusted.sort((a, b) => {
        if (!a && !b) return 0;
        if (!a) return 1;
        if (!b) return -1;

        // 保留:bye 放最後
        if (a.bye && !b.bye) return 1;
        if (b.bye && !a.bye) return -1;

        // 取得兩場中各選手的 matchPoints(若不存在則視為 0)
        const a1 = Number(a.player1 ? a.player1.matchPoints || 0 : 0);
        const a2 = Number(a.player2 ? a.player2.matchPoints || 0 : 0);
        const b1 = Number(b.player1 ? b.player1.matchPoints || 0 : 0);
        const b2 = Number(b.player2 ? b.player2.matchPoints || 0 : 0);

        // **主要排序:先比場中最高分(max)**(高者優先)
        const maxA = Math.max(a1, a2);
        const maxB = Math.max(b1, b2);
        if (maxB !== maxA) return maxB - maxA;

        // 次要排序:再比總分(高者優先)
        const sa = a1 + a2;
        const sb = b1 + b2;
        if (sb !== sa) return sb - sa;

        return 0; // 仍然完全相等時保留原順序
      });

      return adjusted;
    } // 函式結束

    function computeCrossingCountUpTo(playerId, uptoRoundInclusive) {
      if (!playerId || !Array.isArray(rounds) || rounds.length === 0) return 0;
      const upto = Math.max(0, Math.min(uptoRoundInclusive, rounds.length));
      let count = 0;
      for (let r = 0; r < upto; r++) {
        const rd = rounds[r];
        if (!rd || !Array.isArray(rd.matches)) continue;
        rd.matches.forEach(m => {
          if (!m) return;
          if (m.bye) {
            if (m.player1 && m.player1.id === playerId) count += 1;
            return;
          }
          let s1 = (typeof m.previousScore1 !== 'undefined') ? Number(m.previousScore1) : null;
          let s2 = (typeof m.previousScore2 !== 'undefined') ? Number(m.previousScore2) : null;
          if (s1 === null || s2 === null) {
            try {
              if (s1 === null && m.player1 && typeof getPlayerScoreAfterRound === 'function') {
                s1 = Number(getPlayerScoreAfterRound(m.player1.id, r) || 0);
              }
              if (s2 === null && m.player2 && typeof getPlayerScoreAfterRound === 'function') {
                s2 = Number(getPlayerScoreAfterRound(m.player2.id, r) || 0);
              }
            } catch (e) {
              if (s1 === null) s1 = 0;
              if (s2 === null) s2 = 0;
            }
          }

          s1 = Number(s1 || 0);
          s2 = Number(s2 || 0);
          if (s1 !== s2) {
            if (m.player1 && m.player1.id === playerId) count += 1;
            if (m.player2 && m.player2.id === playerId) count += 1;
          }
        });
      }
      return count;
    }

    function displayRound(roundNum) {
      function safeComputeCrossing(playerId, uptoRound) {
        try {
          if (typeof computeCrossingCountUpTo === 'function') {
            return computeCrossingCountUpTo(playerId, uptoRound) || 0;
          }
        } catch (e) { }
        return 0;
      }
      function makeCrossingHtml(n) {
        const nSafe = Number(n || 0);
        if (nSafe === 0) {
          return `<span style="font-size:70%; margin-left:8px; color:#ffffff;">#${nSafe}</span>`;
        } else {
          return `<span style="font-size:70%; margin-left:8px; color:rgba(0,0,0,0.65);">#${nSafe}</span>`;
        }
      }

      viewRound = roundNum;
      roundTitle.textContent = `第${roundNum}輪對陣表`;
      let navButtons = document.querySelectorAll("#roundNav button");
      navButtons.forEach(btn => {
        if (parseInt(btn.dataset.round) === roundNum) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });

      roundContainer.innerHTML = "";

      if (roundNum > currentRound) {
        let msg = document.createElement("div");
        msg.textContent = "該輪尚未開始";
        roundContainer.appendChild(msg);
        submitRoundBtn.style.display = "none";
        nextRoundBtn.style.display = "none";
        removeRoundBtn.style.display = "none";
        return;
      }

      let roundData = rounds[roundNum - 1];

      if (roundNum === currentRound && !roundData) {
        try {
          recalculatePlayerStatsUpTo(Math.max(0, currentRound - 1));
        } catch (e) { console.warn('recalc failed before pairing', e); }

        let newPairings = generatePairingsByMode();
        newPairings.sort((a, b) => (a.bye ? 1 : 0) - (b.bye ? 1 : 0));
        const arrangedAtISO = new Date().toISOString();
        roundData = { round: currentRound, matches: newPairings, submitted: false, arrangedAt: arrangedAtISO };
        rounds[currentRound - 1] = roundData;
      }

      if (!roundData) {
        let msg = document.createElement("div");
        msg.textContent = "該輪資料不存在";
        roundContainer.appendChild(msg);
        submitRoundBtn.style.display = "none";
        nextRoundBtn.style.display = "none";
        removeRoundBtn.style.display = "none";
        return;
      }

      const prevRoundNum = Math.max(0, roundNum - 1);
      roundData.matches.forEach(m => {
        if (!m) return;
        if (m.bye) {
          if (m.player1) {
            if (typeof m.previousScore1 === 'undefined') {
              if (typeof getPlayerScoreAfterRound === 'function') {
                m.previousScore1 = Number(getPlayerScoreAfterRound(m.player1.id, prevRoundNum) || 0);
              } else {
                m.previousScore1 = Number(m.player1.matchPoints || 0);
              }
            } else {
              m.previousScore1 = Number(m.previousScore1 || 0);
            }
          }
        } else {
          if (m.player1) {
            if (typeof m.previousScore1 === 'undefined') {
              if (typeof getPlayerScoreAfterRound === 'function') {
                m.previousScore1 = Number(getPlayerScoreAfterRound(m.player1.id, prevRoundNum) || 0);
              } else {
                m.previousScore1 = Number(m.player1.matchPoints || 0);
              }
            } else {
              m.previousScore1 = Number(m.previousScore1 || 0);
            }
          }
          if (m.player2) {
            if (typeof m.previousScore2 === 'undefined') {
              if (typeof getPlayerScoreAfterRound === 'function') {
                m.previousScore2 = Number(getPlayerScoreAfterRound(m.player2.id, prevRoundNum) || 0);
              } else {
                m.previousScore2 = Number(m.player2.matchPoints || 0);
              }
            } else {
              m.previousScore2 = Number(m.previousScore2 || 0);
            }
          }
        }
      });

      let table = document.createElement("table");
      table.id = "matchTable";
      let thead = document.createElement("thead");
      let headerRow = document.createElement("tr");
      let th1 = document.createElement("th");
      th1.textContent = "台次";
      let th2 = document.createElement("th");
      th2.textContent = "對戰";
      headerRow.appendChild(th1);
      headerRow.appendChild(th2);
      thead.appendChild(headerRow);
      table.appendChild(thead);
      let tbody = document.createElement("tbody");

      roundData.matches.forEach((match, index) => {
        let tr = document.createElement("tr");
        let tdTable = document.createElement("td");
        if (!match.bye) {
          tdTable.textContent = `第 ${index + 1} 台`;
        } else {
          tdTable.textContent = "";
        }
        tr.appendChild(tdTable);
        let tdBattle = document.createElement("td");
        let containerDiv = document.createElement("div");
        containerDiv.className = "match-row";

        if (match.bye) {
          let leftDiv = document.createElement("div");
          leftDiv.className = "match-player";
          const prevScore = (typeof match.previousScore1 !== 'undefined') ? match.previousScore1 : ((typeof getPlayerScoreAfterRound === 'function') ? (getPlayerScoreAfterRound(match.player1 && match.player1.id, prevRoundNum) || 0) : 0);
          const crossingCount1 = safeComputeCrossing(match.player1 && match.player1.id, roundNum);
          const crossingHtml1 = makeCrossingHtml(crossingCount1);
          leftDiv.innerHTML = `
        <strong
          class="player-name"
          data-match-index="${index}"
          data-player-type="1"
          data-player-id="${match.player1.id}"
        >
          <span class="print-player-number">${String(match.player1.number).padStart(2, '0')}.</span>
          <span class="print-player-name">${match.player1.name}</span>
        </strong>
        (分數: ${prevScore}) ${crossingHtml1}
      `;
          const pn1 = leftDiv.querySelector('.player-name');
          if (pn1) pn1.addEventListener('click', handlePlayerClick);
          containerDiv.appendChild(leftDiv);

          let resultDiv = document.createElement("div");
          resultDiv.className = "match-result";
          resultDiv.textContent = "輪空 (自動2:0)";
          containerDiv.appendChild(resultDiv);

          let rightDiv = document.createElement("div");
          rightDiv.className = "match-player";
          rightDiv.innerHTML = `
        <strong
          class="player-name"
          data-match-index="${index}"
          data-player-type="2"
          data-player-id=""
        >
          輪空
        </strong>
      `;
          const pn2 = rightDiv.querySelector('.player-name');
          if (pn2) pn2.addEventListener('click', handlePlayerClick);
          containerDiv.appendChild(rightDiv);
        } else {
          let leftDiv = document.createElement("div");
          leftDiv.className = "match-player";
          const prevScore1 = (typeof match.previousScore1 !== 'undefined') ? match.previousScore1 : ((typeof getPlayerScoreAfterRound === 'function') ? (getPlayerScoreAfterRound(match.player1 && match.player1.id, prevRoundNum) || 0) : 0);
          const crossingCount1 = safeComputeCrossing(match.player1 && match.player1.id, roundNum);
          const crossingHtml1 = makeCrossingHtml(crossingCount1);
          leftDiv.innerHTML = `
        <strong class="player-name" data-match-index="${index}" data-player-type="1" data-player-id="${match.player1.id}">
          <span class="print-player-number">${String(match.player1.number).padStart(2, '0')}.</span>
          <span class="print-player-name">${match.player1.name}</span>
        </strong>
        (分數: ${prevScore1}) ${crossingHtml1}
      `;
          const lpn = leftDiv.querySelector('.player-name');
          if (lpn) lpn.addEventListener('click', handlePlayerClick);
          containerDiv.appendChild(leftDiv);

          let resultDiv = document.createElement("div");
          resultDiv.className = "match-result";
          if (roundData.submitted || roundNum < currentRound) {
            let span = document.createElement("span");
            span.textContent = match.result;
            span.className = "result-btn selected";
            resultDiv.appendChild(span);
          } else {
            ["2:0", "1:1", "0:2"].forEach(res => {
              let btn = document.createElement("button");
              btn.textContent = res;
              btn.className = "result-btn special-light" + (match.result === res ? " selected" : "");
              btn.addEventListener("click", () => {
                if (match.result === res) {
                  match.result = null;
                  btn.classList.remove("selected");
                } else {
                  match.result = res;
                  resultDiv.querySelectorAll("button").forEach(b => b.classList.remove("selected"));
                  btn.classList.add("selected");
                }
                updateScoreboardFor(currentRound);
                updatePlayersList();
                saveState();
              });
              resultDiv.appendChild(btn);
            });
          }
          containerDiv.appendChild(resultDiv);

          let rightDiv = document.createElement("div");
          rightDiv.className = "match-player";
          const prevScore2 = (typeof match.previousScore2 !== 'undefined') ? match.previousScore2 : ((typeof getPlayerScoreAfterRound === 'function') ? (getPlayerScoreAfterRound(match.player2 && match.player2.id, prevRoundNum) || 0) : 0);
          const crossingCount2 = safeComputeCrossing(match.player2 && match.player2.id, roundNum);
          const crossingHtml2 = makeCrossingHtml(crossingCount2);
          rightDiv.innerHTML = `
        <strong class="player-name" data-match-index="${index}" data-player-type="2" data-player-id="${match.player2.id}">
          <span class="print-player-number">${String(match.player2.number).padStart(2, '0')}.</span>
          <span class="print-player-name">${match.player2.name}</span>
        </strong>
        (分數: ${prevScore2}) ${crossingHtml2}
      `;
          const rpn = rightDiv.querySelector('.player-name');
          if (rpn) rpn.addEventListener('click', handlePlayerClick);
          containerDiv.appendChild(rightDiv);
        }

        tdBattle.appendChild(containerDiv);
        tr.appendChild(tdBattle);
        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      roundContainer.appendChild(table);
      if (!roundData.submitted && roundNum === currentRound) {
        submitRoundBtn.style.display = "inline-block";
      } else {
        submitRoundBtn.style.display = "none";
      }
      if (roundNum === currentRound && currentRound < totalRounds && roundData.submitted) {
        nextRoundBtn.style.display = "inline-block";
      } else {
        nextRoundBtn.style.display = "none";
      }
      removeRoundBtn.style.display = "inline-block";
      updateScoreboardFor(currentRound);
      updatePlayersList();
      saveState();
    }

    const handlePlayerClick = (event) => {
      event.stopPropagation();
      const target = event.currentTarget;
      const matchIndex = parseInt(target.dataset.matchIndex);
      const playerType = target.dataset.playerType;
      const currentRoundData = rounds[viewRound - 1];
      if (!currentRoundData || currentRoundData.submitted) {
        alert("本輪已提交,無法修改對陣！");
        return;
      }
      if (!selectedPlayer) {
        selectedPlayer = {
          matchIndex,
          playerType,
          element: target,
          match: currentRoundData.matches[matchIndex]
        };
        target.classList.add('selected');
      } else {
        const first = selectedPlayer;
        const second = {
          matchIndex,
          playerType,
          element: target,
          match: currentRoundData.matches[matchIndex]
        };
        swapPlayers(first, second);
        clearSelection();
      }
    };

    function playedBefore(playerAId, playerBId, uptoRoundExclusive) {
      if (!playerAId || !playerBId) return false;
      const upto = Math.max(0, Math.min(uptoRoundExclusive, rounds.length));
      for (let r = 0; r < upto; r++) {
        const rd = rounds[r];
        if (!rd || !Array.isArray(rd.matches)) continue;
        for (const m of rd.matches) {
          if (!m || m.bye) continue;
          const id1 = m.player1 && m.player1.id;
          const id2 = m.player2 && m.player2.id;
          if (!id1 || !id2) continue;
          if ((id1 === playerAId && id2 === playerBId) || (id1 === playerBId && id2 === playerAId)) {
            return true;
          }
        }
      }
      return false;
    }

    function pairKey(a, b) {
      if (!a || !b) return null;
      const x = Number(a), y = Number(b);
      return x < y ? `${x}_${y}` : `${y}_${x}`;
    }

    const swapPlayers = (first, second) => {
      try {
        const roundIndex = Math.max(0, (viewRound || currentRound) - 1);
        const roundData = rounds[roundIndex];
        if (!roundData || !Array.isArray(roundData.matches)) return;

        const firstMatch = first.match;
        const secondMatch = second.match;
        if (!firstMatch || !secondMatch) return;

        if (first.matchIndex === second.matchIndex) {
          const m = roundData.matches[first.matchIndex];
          if (!m) return;
          if (m.bye || !m.player1 || !m.player2) return;

          const tmpP1 = m.player1;
          const tmpP2 = m.player2;
          m.player1 = tmpP2;
          m.player2 = tmpP1;

          const prevRoundNum = Math.max(0, viewRound - 1);
          if (m.player1) m.previousScore1 = Number(getPlayerScoreAfterRound(m.player1.id, prevRoundNum) || 0);
          if (m.player2) m.previousScore2 = Number(getPlayerScoreAfterRound(m.player2.id, prevRoundNum) || 0);

          displayRound(viewRound);
          updateScoreboardFor(currentRound);
          updatePlayersList();
          saveState();
          return;
        }

        const pA = (first.playerType === '1') ? firstMatch.player1 : firstMatch.player2;
        const pB = (second.playerType === '1') ? secondMatch.player1 : secondMatch.player2;
        if (!pA || !pB) return;
        if (pA.id === pB.id) return;

        const m1 = {
          player1: firstMatch.player1,
          player2: firstMatch.player2,
          bye: !!firstMatch.bye
        };
        const m2 = {
          player1: secondMatch.player1,
          player2: secondMatch.player2,
          bye: !!secondMatch.bye
        };

        if (first.playerType === '1') {
          if (second.playerType === '1') {
            m1.player1 = pB;
            m2.player1 = pA;
          } else {
            m1.player1 = pB;
            m2.player2 = pA;
          }
        } else {
          if (second.playerType === '1') {
            m1.player2 = pB;
            m2.player1 = pA;
          } else {
            m1.player2 = pB;
            m2.player2 = pA;
          }
        }

        if ((m1.player1 && m1.player2 && m1.player1.id === m1.player2.id) ||
          (m2.player1 && m2.player2 && m2.player1.id === m2.player2.id)) {
          return;
        }

        function pairKey(a, b) {
          if (!a || !b) return null;
          const x = Number(a), y = Number(b);
          return x < y ? `${x}_${y}` : `${y}_${x}`;
        }

        const checks = [];
        if (!m1.bye && m1.player1 && m1.player2) checks.push([m1.player1.id, m1.player2.id]);
        if (!m2.bye && m2.player1 && m2.player2) checks.push([m2.player1.id, m2.player2.id]);

        function playedBefore(playerAId, playerBId, uptoRoundExclusive) {
          if (!playerAId || !playerBId) return false;
          const upto = Math.max(0, Math.min(uptoRoundExclusive, rounds.length));
          for (let r = 0; r < upto; r++) {
            const rd = rounds[r];
            if (!rd || !Array.isArray(rd.matches)) continue;
            for (const mm of rd.matches) {
              if (!mm || mm.bye) continue;
              const id1 = mm.player1 && mm.player1.id;
              const id2 = mm.player2 && mm.player2.id;
              if (!id1 || !id2) continue;
              if ((id1 === playerAId && id2 === playerBId) || (id1 === playerBId && id2 === playerAId)) {
                return true;
              }
            }
          }
          return false;
        }

        for (const [idA, idB] of checks) {
          const already = playedBefore(idA, idB, (viewRound || currentRound) - 1);
          if (already) {
            return;
          }
        }

        const otherPairKeys = new Set();
        roundData.matches.forEach((m, idx) => {
          if (idx === first.matchIndex || idx === second.matchIndex) return;
          if (!m || m.bye) return;
          const id1 = m.player1 && m.player1.id;
          const id2 = m.player2 && m.player2.id;
          const k = pairKey(id1, id2);
          if (k) otherPairKeys.add(k);
        });

        const newPair1Key = (m1.bye || !m1.player1 || !m1.player2) ? null : pairKey(m1.player1.id, m1.player2.id);
        const newPair2Key = (m2.bye || !m2.player1 || !m2.player2) ? null : pairKey(m2.player1.id, m2.player2.id);

        if (newPair1Key && otherPairKeys.has(newPair1Key)) return;
        if (newPair2Key && otherPairKeys.has(newPair2Key)) return;
        if (newPair1Key && newPair2Key && newPair1Key === newPair2Key) return;

        const orig1 = roundData.matches[first.matchIndex];
        const orig2 = roundData.matches[second.matchIndex];

        if (first.playerType === '1') {
          if (second.playerType === '1') {
            orig1.player1 = pB;
            orig2.player1 = pA;
          } else {
            orig1.player1 = pB;
            orig2.player2 = pA;
          }
        } else {
          if (second.playerType === '1') {
            orig1.player2 = pB;
            orig2.player1 = pA;
          } else {
            orig1.player2 = pB;
            orig2.player2 = pA;
          }
        }

        const prevRoundNum = Math.max(0, viewRound - 1);
        [orig1, orig2].forEach(m => {
          if (!m) return;
          if (m.bye) {
            if (m.player1) m.previousScore1 = Number(getPlayerScoreAfterRound(m.player1.id, prevRoundNum) || 0);
            delete m.previousScore2;
          } else {
            if (m.player1) m.previousScore1 = Number(getPlayerScoreAfterRound(m.player1.id, prevRoundNum) || 0);
            if (m.player2) m.previousScore2 = Number(getPlayerScoreAfterRound(m.player2.id, prevRoundNum) || 0);
          }
        });

        displayRound(viewRound);
        updateScoreboardFor(currentRound);
        updatePlayersList();
        saveState();
      } catch (err) {
        console.error('swapPlayers failed', err);
      }
    };


    const updatePlayerDisplay = (element, player, playerType, matchIndex) => {
      if (!element) return;
      if (!player) {
        element.innerHTML = `<span class="print-player-number">--.</span><span class="print-player-name">輪空</span>`;
        element.dataset.playerId = "";
        if (typeof matchIndex !== 'undefined') element.dataset.matchIndex = matchIndex;
        if (typeof playerType !== 'undefined') element.dataset.playerType = playerType;
        element.removeEventListener('click', handlePlayerClick);
        element.addEventListener('click', handlePlayerClick);
        return;
      }

      const number = String(player.number || "").padStart(2, '0');
      element.innerHTML = `
    <span class="print-player-number">${number}.</span>
    <span class="print-player-name">${player.name}</span>
  `;
      element.dataset.playerId = player.id;
      if (typeof matchIndex !== 'undefined') element.dataset.matchIndex = matchIndex;
      if (typeof playerType !== 'undefined') element.dataset.playerType = playerType;

      element.removeEventListener('click', handlePlayerClick);
      element.addEventListener('click', handlePlayerClick);
    };

    const clearSelection = () => {
      document.querySelectorAll('.player-name.selected').forEach(el => {
        el.classList.remove('selected');
      });
      selectedPlayer = null;
    };
    document.addEventListener('click', clearSelection);

    function processMatchResult(match) {
      if (match.bye) {
        match.player1.roundResults.push({
          round: currentRound,
          opponent: "BYE",
          opponentId: null,
          outcome: "Win",
          opponentScore: match.player1.matchPoints
        });
        match.player1.matchPoints += 2;
        match.player1.pointsHistory.push(match.player1.matchPoints);
        match.player1.hadBye = true;
      } else {
        let p1Before = match.player1.matchPoints;
        let p2Before = match.player2.matchPoints;
        switch (match.result) {
          case "2:0":
            match.player1.roundResults.push({
              round: currentRound,
              opponent: match.player2.name,
              opponentId: match.player2.id,
              outcome: "Win",
              opponentScore: p2Before
            });
            match.player2.roundResults.push({
              round: currentRound,
              opponent: match.player1.name,
              opponentId: match.player1.id,
              outcome: "Lose",
              opponentScore: p1Before
            });
            match.player1.matchPoints += 2;
            match.player1.pointsHistory.push(match.player1.matchPoints);
            match.player2.pointsHistory.push(match.player2.matchPoints);
            match.player1.opponents.push(match.player2.id);
            match.player2.opponents.push(match.player1.id);
            break;
          case "0:2":
            match.player1.roundResults.push({
              round: currentRound,
              opponent: match.player2.name,
              opponentId: match.player2.id,
              outcome: "Lose",
              opponentScore: p2Before
            });
            match.player2.roundResults.push({
              round: currentRound,
              opponent: match.player1.name,
              opponentId: match.player1.id,
              outcome: "Win",
              opponentScore: p1Before
            });
            match.player2.matchPoints += 2;
            match.player1.pointsHistory.push(match.player1.matchPoints);
            match.player2.pointsHistory.push(match.player2.matchPoints);
            match.player1.opponents.push(match.player2.id);
            match.player2.opponents.push(match.player1.id);
            break;
          case "1:1":
            match.player1.roundResults.push({
              round: currentRound,
              opponent: match.player2.name,
              opponentId: match.player2.id,
              outcome: "Draw",
              opponentScore: p2Before
            });
            match.player2.roundResults.push({
              round: currentRound,
              opponent: match.player1.name,
              opponentId: match.player1.id,
              outcome: "Draw",
              opponentScore: p1Before
            });
            match.player1.matchPoints += 1;
            match.player2.matchPoints += 1;
            match.player1.pointsHistory.push(match.player1.matchPoints);
            match.player2.pointsHistory.push(match.player2.matchPoints);
            match.player1.opponents.push(match.player2.id);
            match.player2.opponents.push(match.player1.id);
            break;
          default:
            throw "未處理的比賽結果";
        }
      }
    }

    function recalculatePlayerStatsUpTo(maxRound) {
      players.forEach(player => {
        player.pointsHistory = [];
        player.matchPoints = 0;
        player.cumulativeScore = 0;
        player.opponents = [];
        player.roundResults = [];
        player.hadBye = false;
      });
      for (let i = 0; i < maxRound; i++) {
        const roundData = rounds[i];
        if (!roundData) break;
        roundData.matches.forEach(match => {
          if (match.bye) {
            match.player1.hadBye = true;
            match.player1.roundResults.push({
              round: roundData.round,
              opponent: "BYE",
              opponentId: null,
              outcome: "Win",
              opponentScore: match.player1.matchPoints
            });
            match.player1.matchPoints += 2;
          } else {
            let p1Before = match.player1.matchPoints;
            let p2Before = match.player2.matchPoints;
            switch (match.result) {
              case "2:0":
                match.player1.matchPoints += 2;
                break;
              case "0:2":
                match.player2.matchPoints += 2;
                break;
              case "1:1":
                match.player1.matchPoints += 1;
                match.player2.matchPoints += 1;
                break;
              default:
                console.error("未處理的比賽結果");
            }
            match.player1.roundResults.push({
              round: roundData.round,
              opponent: match.player2.name,
              opponentId: match.player2.id,
              outcome: match.result === "2:0" ? "Win" : match.result === "0:2" ? "Lose" : "Draw",
              opponentScore: p2Before
            });
            match.player2.roundResults.push({
              round: roundData.round,
              opponent: match.player1.name,
              opponentId: match.player1.id,
              outcome: match.result === "0:2" ? "Win" : match.result === "2:0" ? "Lose" : "Draw",
              opponentScore: p1Before
            });
            match.player1.opponents.push(match.player2.id);
            match.player2.opponents.push(match.player1.id);
          }
        });
        players.forEach(player => {
          player.pointsHistory.push(player.matchPoints);
          player.cumulativeScore = player.pointsHistory.reduce((sum, v) => sum + v, 0);
        });
      }
    }

    function computeStatsFor(roundNum) {
      let clones = players.map(p => ({
        id: p.id,
        number: p.number,
        name: p.name,
        team: p.team,
        matchPoints: 0,
        pointsHistory: [],
        cumulativeScore: 0,
        opponents: [],
        roundResults: [],
        hadBye: false,
        isFinalist: p.isFinalist,
        isFemale: p.isFemale,
        isCancelled: p.isCancelled,
        rank: p.rank
      }));
      for (let i = 0; i < roundNum; i++) {
        let roundData = rounds[i];
        if (!roundData) break;
        roundData.matches.forEach(match => {
          if (match.bye) {
            let p = clones.find(x => x.id === match.player1.id);
            if (p) {
              p.roundResults.push({
                round: i + 1,
                opponent: "BYE",
                opponentId: null,
                outcome: "Win",
                opponentScore: p.matchPoints
              });
              p.matchPoints += 2;
            }
          } else {
            let p1 = clones.find(x => x.id === match.player1.id);
            let p2 = clones.find(x => x.id === match.player2.id);
            if (p1 && p2) {
              if (match.result) {
                let p1Before = p1.matchPoints;
                let p2Before = p2.matchPoints;
                if (match.result === "2:0") {
                  p1.roundResults.push({
                    round: i + 1,
                    opponent: match.player2.name,
                    opponentId: match.player2.id,
                    outcome: "Win",
                    opponentScore: p2Before
                  });
                  p2.roundResults.push({
                    round: i + 1,
                    opponent: match.player1.name,
                    opponentId: match.player1.id,
                    outcome: "Lose",
                    opponentScore: p1Before
                  });
                  p1.matchPoints += 2;
                  p1.opponents.push(match.player2.id);
                  p2.opponents.push(match.player1.id);
                } else if (match.result === "0:2") {
                  p1.roundResults.push({
                    round: i + 1,
                    opponent: match.player2.name,
                    opponentId: match.player2.id,
                    outcome: "Lose",
                    opponentScore: p2Before
                  });
                  p2.roundResults.push({
                    round: i + 1,
                    opponent: match.player1.name,
                    opponentId: match.player1.id,
                    outcome: "Win",
                    opponentScore: p1Before
                  });
                  p2.matchPoints += 2;
                  p1.opponents.push(match.player2.id);
                  p2.opponents.push(match.player1.id);
                } else if (match.result === "1:1") {
                  p1.roundResults.push({
                    round: i + 1,
                    opponent: match.player2.name,
                    opponentId: match.player2.id,
                    outcome: "Draw",
                    opponentScore: p2Before
                  });
                  p2.roundResults.push({
                    round: i + 1,
                    opponent: match.player1.name,
                    opponentId: match.player1.id,
                    outcome: "Draw",
                    opponentScore: p1Before
                  });
                  p1.matchPoints += 1;
                  p2.matchPoints += 1;
                  p1.opponents.push(match.player2.id);
                  p2.opponents.push(match.player1.id);
                }
              } else {
                p1.roundResults.push({
                  round: i + 1,
                  opponent: match.player2.name,
                  opponentId: match.player2.id,
                  outcome: "待定",
                  opponentScore: p2.matchPoints
                });
                p2.roundResults.push({
                  round: i + 1,
                  opponent: match.player1.name,
                  opponentId: match.player1.id,
                  outcome: "待定",
                  opponentScore: p1.matchPoints
                });
              }
            }
          }
        });
        clones.forEach(p => {
          p.pointsHistory.push(p.matchPoints);
          p.cumulativeScore = p.pointsHistory.reduce((sum, v) => sum + v, 0);
        });
      }
      return clones;
    }

    function getPlayerScoreAfterRound(playerId, round) {
      if (!playerId) return 0;
      if (!round || round <= 0) return 0;
      const clones = computeStatsFor(round);
      const p = clones.find(x => x.id === playerId);
      return p ? p.matchPoints : 0;
    }


    function getUniqueOpponentScoreSim(player, computedPlayers) {
      let uniqueOpp = new Set();
      let sum = 0;
      let breakdown = [];
      player.roundResults.forEach(r => {
        if (r.opponentId !== null && !uniqueOpp.has(r.opponentId)) {
          uniqueOpp.add(r.opponentId);
          const opp = computedPlayers.find(p => p.id === r.opponentId);
          if (opp) {
            sum += opp.matchPoints;
            breakdown.push(opp.matchPoints);
          }
        }
      });
      return { total: sum, breakdown };
    }

    function updateScoreboardFor(roundNum) {
      const computedPlayers = computeStatsFor(roundNum);

      function getOppMatchPoints(player) {
        const uniqueOpp = new Set();
        let total = 0;
        const breakdown = [];
        player.roundResults.forEach(r => {
          if (r.opponentId !== null && !uniqueOpp.has(r.opponentId)) {
            uniqueOpp.add(r.opponentId);
            const opp = computedPlayers.find(p => p.id === r.opponentId);
            if (opp) {
              total += opp.matchPoints;
              breakdown.push(opp.matchPoints);
            }
          }
        });
        return {
          total,
          breakdown
        };
      }

      if (useAvgOppRank) {
        computedPlayers.forEach(p => p.avgOppRank = Number.MAX_SAFE_INTEGER);
        const maxIter = 10;
        let prevRankingMap = {};
        for (let iter = 0; iter < maxIter; iter++) {
          const sorted = computedPlayers.slice().sort((a, b) => {
            if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints;
            const ao = getOppMatchPoints(a).total;
            const bo = getOppMatchPoints(b).total;
            if (bo !== ao) return bo - ao;
            if (b.cumulativeScore !== a.cumulativeScore) return b.cumulativeScore - a.cumulativeScore;
            return a.avgOppRank - b.avgOppRank;
          });
          const rankingMap = {};
          sorted.forEach((p, i) => {
            rankingMap[p.id] = i === 0 ? 1 : ((p.matchPoints === sorted[i - 1].matchPoints &&
              getOppMatchPoints(p).total === getOppMatchPoints(sorted[i - 1]).total &&
              p.cumulativeScore === sorted[i - 1].cumulativeScore &&
              Math.abs(p.avgOppRank - sorted[i - 1].avgOppRank) < 1e-6) ?
              rankingMap[sorted[i - 1].id] : i + 1);
          });
          if (iter > 0 && Object.keys(rankingMap).every(id => rankingMap[id] === prevRankingMap[id])) break;
          prevRankingMap = rankingMap;
          computedPlayers.forEach(p => {
            const oppIds = p.roundResults.map(r => r.opponentId).filter(id => id !== null);
            p.avgOppRank = oppIds.length ? oppIds.reduce((sum, id) => sum + (rankingMap[id] || 0), 0) / oppIds.length : Number.MAX_SAFE_INTEGER;
          });
        }
      } else {
        computedPlayers.forEach(p => p.avgOppRank = null);
      }

      const finalSorted = computedPlayers.slice().sort((a, b) => {
        if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints;
        const ao = getOppMatchPoints(a).total;
        const bo = getOppMatchPoints(b).total;
        if (bo !== ao) return bo - ao;
        if (b.cumulativeScore !== a.cumulativeScore) return b.cumulativeScore - a.cumulativeScore;
        if (useAvgOppRank) {
          if (a.avgOppRank === null && b.avgOppRank === null) return 0;
          if (a.avgOppRank === null) return 1;
          if (b.avgOppRank === null) return -1;
          return a.avgOppRank - b.avgOppRank;
        }
        return 0;
      });

      const finalRankingMap = {};
      finalSorted.forEach((p, i) => {
        finalRankingMap[p.id] = i === 0 ? 1 : ((p.matchPoints === finalSorted[i - 1].matchPoints &&
          getOppMatchPoints(p).total === getOppMatchPoints(finalSorted[i - 1]).total &&
          p.cumulativeScore === finalSorted[i - 1].cumulativeScore &&
          ((useAvgOppRank && Math.abs(p.avgOppRank - finalSorted[i - 1].avgOppRank) < 1e-6) || !useAvgOppRank)) ?
          finalRankingMap[finalSorted[i - 1].id] : i + 1);
      });

      scoreboardTitle.textContent = `完成 ${roundNum} 輪後的成績總表`;
      scoreboardBody.innerHTML = '';

      finalSorted.forEach(player => {
        const oppMP = getOppMatchPoints(player);

        const markerElements = [];
        if (player.rank) markerElements.push({ text: `評為${player.rank}`, cls: 'marker-span marker-reward' });
        if (player.isFinalist) markerElements.push({ text: '入選', cls: 'marker-span marker-isFinalist' });
        if (player.isFemale) markerElements.push({ text: '女棋手', cls: 'marker-span marker-female' });
        if (player.isCancelled) markerElements.push({ text: '取消成績', cls: 'marker-span marker-cancel' });

        const tr = document.createElement('tr');
        let td = document.createElement('td'); td.textContent = finalRankingMap[player.id]; tr.appendChild(td);
        td = document.createElement('td'); td.textContent = player.name; tr.appendChild(td);
        td = document.createElement('td');
        if (markerElements.length) {
          td.innerHTML = markerElements.map(m => `<div class="${m.cls}">${m.text}</div>`).join('');
        } else {
          td.textContent = '-';
        }
        tr.appendChild(td);
        td = document.createElement('td'); td.textContent = player.matchPoints; tr.appendChild(td);
        td = document.createElement('td'); td.textContent = oppMP.total; tr.appendChild(td);
        td = document.createElement('td'); td.textContent = oppMP.breakdown.join('+'); tr.appendChild(td);
        td = document.createElement('td'); td.textContent = player.cumulativeScore; tr.appendChild(td);
        td = document.createElement('td'); td.textContent = player.pointsHistory.join('+'); tr.appendChild(td);
        td = document.createElement('td'); td.textContent = player.team || '-'; tr.appendChild(td);
        scoreboardBody.appendChild(tr);

        const historyTr = document.createElement('tr'); historyTr.className = 'history-row';
        const historyTd = document.createElement('td'); historyTd.colSpan = 9;
        const histArr = player.roundResults.map(r => {
          const m = r.outcome === 'Win' ? 'W' : r.outcome === 'Lose' ? 'L' : r.outcome === 'Draw' ? 'D' : '?';
          const oppRank = r.opponentId ? finalRankingMap[r.opponentId] : '';
          const oppName = r.opponent === 'BYE' ? '輪空' : `${r.opponent}${oppRank ? `(${oppRank})` : ''}`;
          const label = m === 'W' ? `<span style="color: red; font-weight: bold;">WIN</span>` : m === 'L' ? `<span style="color: blue; font-weight: bold;">LOSE</span>` : m;
          return `<div class="history-item">R${r.round}:${label}-${oppName}</div>`;
        });

        let extraCols = (useAvgOppRank && player.avgOppRank !== null && isFinite(player.avgOppRank)) ? 1 : 0;
        let cols = Math.max(player.roundResults.length + extraCols, 1);

        let avgHtml = '';
        if (useAvgOppRank && player.avgOppRank !== null && isFinite(player.avgOppRank)) {
          avgHtml = `<div class="history-item"><span style="color: #f1c40f;">平均名次:</span><span style="color: black;">${player.avgOppRank.toFixed(1)}</span><span style="color: #f1c40f;">名</span></div>`;
        }

        historyTd.innerHTML = `
  <div class="history-box" style="display: grid; grid-template-columns: repeat(${cols}, 1fr); gap: 0.5rem; align-items: center;">
    ${histArr.join('')}
    ${avgHtml}
  </div>
`;

        historyTr.appendChild(historyTd);
        scoreboardBody.appendChild(historyTr);
      });

      playerRankOrder = finalSorted.map(p => p.id);
      saveState();
    }

    document.getElementById("printPairingsBtn").addEventListener("click", function () {
      printSection("roundSection");
    });
    document.getElementById("printScoreboardBtn").addEventListener("click", function () {
      printSection("scoreboard");
    });

    function printSection(sectionId) {
      const roundData = rounds[viewRound - 1];
      const hasResults = roundData && roundData.submitted === true;

      let filename;
      if (sectionId === "scoreboard") {
        filename = `${tournamentName} 成績總表`;
      } else {
        filename = `${tournamentName} 第${viewRound}輪對陣表` + (hasResults ? ' 附上成績' : '');
      }
      const timeControlSelect = document.getElementById("timeControl");
      const timeControlText = timeControlSelect.options[timeControlSelect.selectedIndex].text;

      const content = document.getElementById(sectionId).outerHTML;

      function buildSafeHeadHTML() {
        const meta = `<meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1">`;
        const links = Array.from(document.querySelectorAll('link[rel="stylesheet"]'))
          .map(l => {
            return l.outerHTML;
          }).join('\n');
        const styles = Array.from(document.querySelectorAll('style'))
          .map(s => s.outerHTML).join('\n');
        return `${meta}\n${links}\n${styles}`;
      }

      const headHTML = buildSafeHeadHTML();
      const fullFooter = '名次排序依序比較積分、對手分及累積分(高分優先)。若仍相同,則根據對手的平均名次決定(對手平均排名靠前者優先)。';
      const shortFooter = '名次排序依序比較積分、對手分及累積分(高分優先)。';
      const footerText = useAvgOppRank ? fullFooter : shortFooter;
      const footerTextForCSS = footerText.replace(/"/g, '\\"');
      const printWindow = window.open('', '_blank', 'width=1000,height=800');
      if (!printWindow) {
        alert('無法開啟列印視窗,請確認是否被阻擋彈出視窗。');
        return;
      }
      printWindow.document.title = filename;
      const runnerScript = `
<script>
  (function(){
    function imagesReady() {
      const imgs = Array.from(document.images || []);
      if (!imgs.length) return Promise.resolve();
      return Promise.all(imgs.map(img => {
        return new Promise(res => {
          if (img.complete) return res();
          img.onload = img.onerror = function(){ res(); };
        });
      }));
    }
    function fontsReady() {
      if (document.fonts && document.fonts.ready) {
        return document.fonts.ready;
      }
      return Promise.resolve();
    }
    function doPrintNow() {
      try { window.focus(); } catch(e) {}
      setTimeout(function(){
        try {
          window.print();
        } catch(e) {
          console.error('print() threw', e);
        }
      }, 120);
    }

    function attemptPrintFlow() {
      Promise.all([imagesReady(), fontsReady()]).then(function(){
        doPrintNow();
      }).catch(function(err){
        console.warn('等待資源失敗或超時:', err);
        setTimeout(doPrintNow, 300);
      });
    }

    if (document.readyState === 'complete') {
      attemptPrintFlow();
    } else {
      window.addEventListener('load', attemptPrintFlow, {once:true});
      setTimeout(function(){
        if (document.readyState !== 'complete') {
          attemptPrintFlow();
        }
      }, 1500);
    }

    window.onafterprint = function() {
      setTimeout(function(){ try { window.close(); } catch(e) {} }, 500);
    };
  })();
<\/script>
`;

      const bodyClass = sectionId === "scoreboard" ? ' class="print-scoreboard"' : '';
      const pairingFooterHtml = `<div class="pairings-footer">#n:至此輪為止,該選手與不同積分對手(或輪空)交手的累計次數。</div>`;

      const html = `<!DOCTYPE html>
<html>
<head>
  <title>${escapeHtml(filename)}</title>
  ${headHTML}
  <style>
    @media print {
      body.print-scoreboard::after {
        content: "${footerTextForCSS}";
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        text-align: center;
        font-size: 13px;
        color: #f1c40f;
      }
        button, input[type="button"], input[type="submit"], .no-print {
    display: none !important;
  }
      .print-group-info h1 {
        font-size: 1.2em !important;
      }
      #scoreboard tbody tr:not(.history-row) {
        height: 26px !important;
      }
      #scoreboard tbody tr,
      #scoreboard tbody tr.history-row {
        height: 18px !important;
      }
      #scoreboard {
        width: 100vw;
        max-width: 100%;
        table-layout: fixed;
      }
      #printScoreboardBtn,
      #printPairingsBtn,
      #submitRoundBtn,
      #nextRoundBtn,
      #removeRoundBtn {
        display: none !important;
      }
      .history-box {
        font-size: 0.45em !important;
        line-height: 0.55 !important;
        top: -4px;
      }
      #scoreboard td, #scoreboard th {
        padding: 4px !important;
      }
    }
  .pairings-footer {
  color: rgba(0,0,0,0.5);
  font-size: 13px;
  line-height: 0;
  text-align: center;
  padding-top: 0px;
  margin-top: -16px;
  margin-bottom: 0;
  border-top: none;
}

    #scoreboard th:nth-child(1),
    #scoreboard td:nth-child(1) { width: 5% !important; }
    #scoreboard th:nth-child(2),
    #scoreboard td:nth-child(2) { width: 14% !important; }
    #scoreboard th:nth-child(3),
    #scoreboard td:nth-child(3) { width: 11.5% !important; }
    #scoreboard th:nth-child(4),
    #scoreboard td:nth-child(4) { width: 6% !important; }
    #scoreboard th:nth-child(5),
    #scoreboard td:nth-child(5) { width: 8% !important; }
    #scoreboard th:nth-child(6),
    #scoreboard td:nth-child(6) { width: 15% !important; }
    #scoreboard th:nth-child(7),
    #scoreboard td:nth-child(7) { width: 8% !important; }
    #scoreboard th:nth-child(8),
    #scoreboard td:nth-child(8) { width: 14% !important; }
    #scoreboard th:nth-child(9),
    #scoreboard td:nth-child(9) { width: 18.5% !important; }
  </style>
</head>
<body${bodyClass}>
  <div class="print-group-info" style="text-align:center; margin-bottom:5px;">
    <h1 style="margin:0; padding:0;">${escapeHtml(tournamentName || '')}</h1>
    <p style="margin:5px 0 0 0; font-size: 1em;">
      ${escapeHtml(tournamentDate || '')}  ||  共 ${totalRounds} 輪  ||  ${escapeHtml(timeControlText)}
    </p>
  </div>
  ${content}
  ${sectionId === 'scoreboard' ? '' : pairingFooterHtml}
  ${runnerScript}
</body>
</html>`;
      printWindow.document.open();
      printWindow.document.write(html);
      printWindow.document.close();
    }


    function escapeHtml(s) {
      if (!s && s !== 0) return '';
      return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }


    nextRoundBtn.addEventListener("click", () => {
      if (currentRound < totalRounds) {
        currentRound++;
        viewRound = currentRound;
        displayRound(currentRound);
        updateScoreboardFor(currentRound);
        updatePlayersList();
        saveState();
      }
    });

    submitRoundBtn.addEventListener("click", () => {
      const currentMatches = rounds[currentRound - 1] && rounds[currentRound - 1].matches;
      if (!Array.isArray(currentMatches)) return;
      for (let match of currentMatches) {
        if (!match.bye && !match.result) {
          alert("請選擇所有比賽的結果！");
          return;
        }
      }

      rounds[currentRound - 1].submitted = true;
      recalculatePlayerStatsUpTo(currentRound);
      if (currentRound === totalRounds) {
        tournamentFinishTime = new Date().toISOString();
      }
      displayRound(currentRound);
      updateScoreboardFor(currentRound);
      updatePlayersList();
      submitRoundBtn.style.display = "none";
      if (currentRound < totalRounds) {
        nextRoundBtn.style.display = "inline-block";
      }
      saveState();
    });

    removeRoundBtn.addEventListener("click", () => {
      if (currentRound === 1 && rounds.length === 0) {
        if (confirm("確定要取消編排並重置比賽嗎？")) {
          rounds = [];
          currentRound = 0;
          players.forEach(p => {
            p.matchPoints = 0;
            p.pointsHistory = [];
            p.cumulativeScore = 0;
            p.opponents = [];
            p.roundResults = [];
            p.hadBye = false;
          });
          updateScoreboardFor(0);
          startTournamentBtn.disabled = false;
          tournamentNameInput.disabled = false;
          tournamentDateInput.disabled = false;
          addBatchPlayersBtn.disabled = false;
          randomizePlayersBtn.disabled = false;
          batchPlayersTextarea.disabled = false;
          roundSection.style.display = "none";
          removeRoundBtn.style.display = "none";
          nextRoundBtn.style.display = "none";
          submitRoundBtn.style.display = "none";
          document.getElementById("roundNav").style.display = "none";
          document.querySelectorAll('.round-btn').forEach(btn => {
            btn.style.display = '';
            btn.disabled = false;
          });
          document.querySelectorAll('.pairing-mode-btn').forEach(btn => {
            btn.style.display = '';
            btn.disabled = false;
          });
          competitionStarted = false;
          updatePlayersList();
          saveState();
          updateLayoutBasedOnWidth();
        }
        return;
      }
      const roundData = rounds[currentRound - 1];
      if (roundData && roundData.submitted) {
        roundData.submitted = false;
        recalculatePlayerStatsUpTo(currentRound - 1);
        updateScoreboardFor(currentRound - 1);
        displayRound(currentRound);
        submitRoundBtn.style.display = "";
        nextRoundBtn.style.display = "none";
        saveState();
        return;
      }
      if (rounds.length > 0) {
        rounds.pop();
        currentRound = rounds.length > 0 ? rounds.length : 1;
        recalculatePlayerStatsUpTo(rounds.length);
        updateScoreboardFor(rounds.length);
        displayRound(currentRound);
        if (rounds.length === 0) {
          removeRoundBtn.textContent = "取消編排";
          roundSection.style.display = "none";
          submitRoundBtn.style.display = "none";
          nextRoundBtn.style.display = "none";
          document.getElementById("roundNav").style.display = "none";
          competitionStarted = false;
        }
        saveState();
        updateLayoutBasedOnWidth();
      }
    });

    async function setFileHandle() {
      try {
        fileHandle = await window.showSaveFilePicker({
          suggestedName: tournamentName + ".json",
          types: [{
            description: "JSON Files",
            accept: { "application/json": [".json"] }
          }]
        });
        saveState();
      } catch (err) {
        console.error("無法設置保存檔:" + err);
      }
    }
    document.getElementById("setFileHandleBtn").addEventListener("click", setFileHandle);

    let __autoSaveTimer = null;
    let __saveInProgress = false;

    function showToast(message, ms = 3000) {
      try {
        const id = 'auto-save-toast';
        let existing = document.getElementById(id);
        if (existing) {
          existing.textContent = message;
          clearTimeout(existing._timeout);
          existing._timeout = setTimeout(() => existing.remove(), ms);
          return;
        }
        const toast = document.createElement('div');
        toast.id = id;
        toast.textContent = message;
        toast.style.position = 'fixed';
        toast.style.right = '20px';
        toast.style.bottom = '24px';
        toast.style.zIndex = 2147483647;
        toast.style.padding = '8px 12px';
        toast.style.background = 'rgba(0,0,0,0.8)';
        toast.style.color = '#fff';
        toast.style.borderRadius = '6px';
        toast.style.fontSize = '13px';
        document.body.appendChild(toast);
        toast._timeout = setTimeout(() => {
          if (toast && toast.parentNode) toast.parentNode.removeChild(toast);
        }, ms);
      } catch (e) {
        console.warn('showToast failed', e);
      }
    }

    async function saveState() {
      if (__autoSaveTimer) clearTimeout(__autoSaveTimer);
      __autoSaveTimer = setTimeout(() => {
        __autoSaveTimer = null;
        _doSaveState();
      }, 250);
    }

    async function _doSaveState() {
      if (__saveInProgress) {
        console.log('saveState: save already in progress, skipping this run.');
        return;
      }
      __saveInProgress = true;

      try {
        const state = {
          tournamentName,
          tournamentDate,
          timeControl,
          players,
          rounds,
          currentRound,
          totalRounds,
          playerIdCounter,
          roundSubmitted,
          competitionStarted,
          pairingMode,
          useAvgOppRank,
          tournamentFinishTime
        };

        function replacer(key, value) {
          if ((key === "player1" || key === "player2") && value && typeof value === "object") {
            return { id: value.id };
          }
          return value;
        }
        let localSaved = false;
        let localErr = null;
        try {
          if (tournamentName && tournamentName.trim() !== "") {
            try {
              localStorage.setItem("tournamentSettings", JSON.stringify({ useAvgOppRank }));
            } catch (e) {
            }
            try {
              localStorage.setItem("tournamentState_" + tournamentName, JSON.stringify(state, replacer, 2));
              localSaved = true;
            } catch (err) {
              localErr = err;
              localSaved = false;
            }
          } else {
          }
        } catch (e) {
          localErr = e;
          localSaved = false;
        }
        let fileSaved = false;
        let fileErr = null;
        if (typeof fileHandle !== 'undefined' && fileHandle) {
          try {
            if (typeof fileHandle.queryPermission === 'function') {
              try {
                const perm = await fileHandle.queryPermission({ mode: 'readwrite' });
                if (perm === 'prompt' && typeof fileHandle.requestPermission === 'function') {
                  await fileHandle.requestPermission({ mode: 'readwrite' });
                }
              } catch (permErr) {
              }
            }

            const text = JSON.stringify(state, replacer, 2);
            try {
              const writable = await fileHandle.createWritable();
              await writable.write(text);
              await writable.close();
              fileSaved = true;
            } catch (fsErr) {
              fileErr = fsErr;
              fileSaved = false;
            }
          } catch (err) {
            fileErr = err;
            fileSaved = false;
          }
        }
        if (localSaved || fileSaved) {
          if (!localSaved && fileSaved) {
          } else if (localSaved && !fileSaved) {
          } else {
          }
        } else {

        }
      } finally {
        __saveInProgress = false;
      }
    }


    function rehydrateRounds() {
      rounds.forEach(round => {
        round.matches.forEach(match => {
          if (match.player1 && typeof match.player1 === 'object' && 'id' in match.player1) {
            match.player1 = players.find(p => p.id === match.player1.id) || match.player1;
          }
          if (match.player2 && typeof match.player2 === 'object' && 'id' in match.player2) {
            match.player2 = players.find(p => p.id === match.player2.id) || match.player2;
          }
        });
      });
    }


    function importState(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function (e) {
        try {
          const state = JSON.parse(e.target.result);
          pairingMode = state.pairingMode || "Z";
          document.querySelectorAll('.pairing-mode-btn').forEach(btn => {
            btn.classList.remove('selected-mode');
            if (btn.dataset.mode === pairingMode) {
              btn.classList.add('selected-mode');
            }
          });

          if (typeof state.useAvgOppRank === "boolean") {
            useAvgOppRank = state.useAvgOppRank;
            const checkbox = document.getElementById("useAvgOppRankCheckbox");
            if (checkbox) checkbox.checked = useAvgOppRank;
            try {
              localStorage.setItem("tournamentSettings", JSON.stringify({ useAvgOppRank }));
            } catch (e) { }
          }

          tournamentName = state.tournamentName;
          tournamentDate = state.tournamentDate;
          tournamentFinishTime = state.tournamentFinishTime || tournamentFinishTime;

          if (state.timeControl) {
            timeControl = state.timeControl;
            document.getElementById('timeControl').value = timeControl;
          }
          updateDocumentTitle();
          players = state.players || players;
          rounds = state.rounds || rounds;
          currentRound = state.currentRound || currentRound;
          totalRounds = state.totalRounds || totalRounds;
          playerIdCounter = state.playerIdCounter || playerIdCounter;
          roundSubmitted = state.roundSubmitted || roundSubmitted;
          competitionStarted = state.competitionStarted || competitionStarted;
          rehydrateRounds();
          tournamentNameInput.value = tournamentName;
          tournamentDateInput.value = tournamentDate;
          tournamentNameInput.disabled = true;
          tournamentDateInput.disabled = true;
          document.querySelectorAll('.round-btn').forEach(btn => {
            if (!btn.classList.contains('selected-round')) {
              btn.style.display = 'none';
            } else {
              btn.style.display = 'inline-block';
              btn.disabled = true;
            }
          });
          document.querySelectorAll('.pairing-mode-btn').forEach(btn => {
            if (!btn.classList.contains('selected-mode')) {
              btn.style.display = 'none';
            } else {
              btn.style.display = '';
              btn.disabled = true;
            }
          });
          const playersSection = document.getElementById("playersSection");
          if (false) {
            playersSection.classList.add('open');
            togglePlayersSectionBtnRef.textContent = "隱藏選手";
          } else {
            playersSection.classList.remove('open');
            togglePlayersSectionBtnRef.textContent = "顯示選手";
          }
          togglePlayersSectionBtnRef.style.display = "inline-block";

          addBatchPlayersBtn.disabled = true;
          randomizePlayersBtn.disabled = true;
          batchPlayersTextarea.disabled = true;
          startTournamentBtn.disabled = true;
          startTournamentBtn.style.display = 'none';
          roundSection.style.display = "block";
          if (scoreboardSection) scoreboardSection.style.display = 'block';

          document.getElementById("roundNav").style.display = "block";
          let roundNavDiv = document.getElementById("roundNav");
          roundNavDiv.innerHTML = "";
          for (let i = 1; i <= totalRounds; i++) {
            let btn = document.createElement("button");
            btn.textContent = "第" + i + "輪";
            btn.dataset.round = i;
            btn.addEventListener("click", () => {
              displayRound(i);
            });
            roundNavDiv.appendChild(btn);
          }
          if (competitionStarted) {
            document.getElementById('batchPlayers').style.display = 'none';
            document.getElementById('addBatchPlayersBtn').style.display = 'none';
            document.getElementById('randomizePlayersBtn').style.display = 'none';
            document.getElementById('clearNumbersBtn').style.display = 'none';
          }
          updatePlayersList();
          viewRound = currentRound;
          displayRound(currentRound);
          updateScoreboardFor(currentRound);
          updatePlayersList();
          saveState();
          updateLayoutBasedOnWidth();
          syncRoundSelectionUI();
        } catch (err) {
          alert("載入進度失敗:" + err);
        }
      }
      reader.readAsText(file);
      event.target.value = "";
    }

    function syncRoundSelectionUI() {
      document.querySelectorAll('#roundSelection .round-btn').forEach(btn => {
        const btnRound = Number(btn.dataset.round);
        const isSelected = (btnRound === Number(totalRounds));
        btn.classList.toggle('selected-round', isSelected);
        if (competitionStarted) {
          btn.disabled = true;
          btn.style.display = isSelected ? 'inline-block' : 'none';
        } else {
          btn.disabled = false;
          btn.style.display = 'inline-block';
        }
      });
    }


    document.getElementById("importStateBtn").addEventListener("click", () => {
      document.getElementById("importFileInput").click();
    });
    document.getElementById("importFileInput").addEventListener("change", importState);

    const updateUI = () => {
      document.getElementById('tournamentName').value = tournamentName;
      document.getElementById('tournamentDate').value = tournamentDate;
      updatePlayersList();
      let roundNavDiv = document.getElementById("roundNav");
      roundNavDiv.innerHTML = "";
      for (let i = 1; i <= totalRounds; i++) {
        let btn = document.createElement("button");
        btn.textContent = "第" + i + "輪";
        btn.dataset.round = i;
        btn.addEventListener("click", () => {
          displayRound(i);
        });
        roundNavDiv.appendChild(btn);
      }
      document.getElementById("roundNav").style.display = "block";
      displayRound(currentRound);
      updateScoreboardFor(currentRound);
      updatePlayersList();
      updateLayoutBasedOnWidth();
    };

    window.addEventListener('beforeunload', (e) => {
      try {
        saveState();
      } catch (err) { }
    });
    (function () {
      function getRoundDataOrNull(r) {
        if (Array.isArray(rounds) && rounds[r - 1]) return rounds[r - 1];
        return null;
      }

      function safePrevScore(match, idx, prevRoundNumForScore) {
        if (!match) return 0;
        if (idx === 1) {
          if (typeof match.previousScore1 !== 'undefined') return Number(match.previousScore1 || 0);
          if (match.player1 && typeof getPlayerScoreAfterRound === 'function') return Number(getPlayerScoreAfterRound(match.player1.id, prevRoundNumForScore) || 0);
          return match.player1 ? Number(match.player1.matchPoints || 0) : 0;
        } else {
          if (typeof match.previousScore2 !== 'undefined') return Number(match.previousScore2 || 0);
          if (match.player2 && typeof getPlayerScoreAfterRound === 'function') return Number(getPlayerScoreAfterRound(match.player2.id, prevRoundNumForScore) || 0);
          return match.player2 ? Number(match.player2.matchPoints || 0) : 0;
        }
      }

      function buildScoreboardSheetData(roundNum) {
        const header = ['名次', '選手名稱', '評級·標記', '積分', '對手分', '對手分細節', '累積分', '累積分細節', '代表隊'];
        const computed = computeStatsFor(roundNum);

        function getOppMatchPointsRow(player) {
          const uniqueOpp = new Set();
          let total = 0;
          const br = [];
          (player.roundResults || []).forEach(r => {
            if (r.opponentId !== null && !uniqueOpp.has(r.opponentId)) {
              uniqueOpp.add(r.opponentId);
              const opp = computed.find(x => x.id === r.opponentId);
              if (opp) {
                total += opp.matchPoints;
                br.push(String(opp.matchPoints));
              }
            }
          });
          return { total, breakdown: br.join('+') };
        }
        if (useAvgOppRank) {
          computed.forEach(p => p.avgOppRank = Number.MAX_SAFE_INTEGER);
          const maxIter = 10;
          let prevRankingMap = {};
          for (let iter = 0; iter < maxIter; iter++) {
            const sorted = computed.slice().sort((a, b) => {
              if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints;
              const ao = getOppMatchPointsRow(a).total;
              const bo = getOppMatchPointsRow(b).total;
              if (bo !== ao) return bo - ao;
              if (b.cumulativeScore !== a.cumulativeScore) return b.cumulativeScore - a.cumulativeScore;
              return a.avgOppRank - b.avgOppRank;
            });
            const rankingMap = {};
            sorted.forEach((p, i) => {
              rankingMap[p.id] = i === 0 ? 1 : ((p.matchPoints === sorted[i - 1].matchPoints &&
                getOppMatchPointsRow(p).total === getOppMatchPointsRow(sorted[i - 1]).total &&
                p.cumulativeScore === sorted[i - 1].cumulativeScore &&
                Math.abs(p.avgOppRank - sorted[i - 1].avgOppRank) < 1e-6) ? rankingMap[sorted[i - 1].id] : i + 1);
            });
            if (iter > 0 && Object.keys(rankingMap).every(id => rankingMap[id] === prevRankingMap[id])) break;
            prevRankingMap = rankingMap;
            computed.forEach(p => {
              const oppIds = p.roundResults.map(r => r.opponentId).filter(id => id !== null);
              p.avgOppRank = oppIds.length ? oppIds.reduce((sum, id) => sum + (rankingMap[id] || 0), 0) / oppIds.length : Number.MAX_SAFE_INTEGER;
            });
          }
        }

        const finalSorted = computed.slice().sort((a, b) => {
          if (b.matchPoints !== a.matchPoints) return b.matchPoints - a.matchPoints;
          const ao = getOppMatchPointsRow(a).total;
          const bo = getOppMatchPointsRow(b).total;
          if (bo !== ao) return bo - ao;
          if (b.cumulativeScore !== a.cumulativeScore) return b.cumulativeScore - a.cumulativeScore;
          if (useAvgOppRank) {
            if (a.avgOppRank === null && b.avgOppRank === null) return 0;
            if (a.avgOppRank === null) return 1;
            if (b.avgOppRank === null) return -1;
            return a.avgOppRank - b.avgOppRank;
          }
          return 0;
        });

        const rows = [header];
        const finalRankingMap = {};
        finalSorted.forEach((p, i) => finalRankingMap[p.id] = i + 1);
        finalSorted.forEach(p => {
          const opp = getOppMatchPointsRow(p);
          const markers = [];
          if (p.rank) markers.push(`評為${p.rank}`);
          if (p.isFinalist) markers.push('入選');
          if (p.isFemale) markers.push('女棋手');
          if (p.isCancelled) markers.push('取消成績');
          rows.push([
            finalRankingMap[p.id],
            p.name,
            markers.length ? markers.join(';') : '-',
            p.matchPoints,
            opp.total,
            opp.breakdown,
            p.cumulativeScore,
            (p.pointsHistory || []).join('+'),
            p.team || '-'
          ]);
        });
        return rows;
      }

      function buildPairingsSheetDataFor(roundIndex) {
        const rd = getRoundDataOrNull(roundIndex);
        const rows = [];
        rows.push([`第${roundIndex}輪 對陣表`]);
        rows.push([]);
        rows.push(['台次', '左(編號)', '左(選手)', '左(賽前分)', '結果', '右(賽前分)', '右(選手)', '右(編號)']);
        if (!rd || !Array.isArray(rd.matches) || rd.matches.length === 0) {
          rows.push(['尚未編排']);
          return rows;
        }
        const prevRoundNumForScore = Math.max(0, roundIndex - 1);
        rd.matches.forEach((m, idx) => {
          if (!m) return;
          if (m.bye) {
            const leftNum = m.player1 ? m.player1.number : '';
            const leftScore = (typeof m.previousScore1 !== 'undefined') ? m.previousScore1 : (m.player1 ? m.player1.matchPoints : 0);
            rows.push([`第${idx + 1}台`, leftNum, m.player1 ? m.player1.name : '輪空', leftScore, '輪空(2:0)', '', '輪空', '']);
          } else {
            const lnum = m.player1 ? m.player1.number : '';
            const rnum = m.player2 ? m.player2.number : '';
            const lscore = safePrevScore(m, 1, prevRoundNumForScore);
            const rscore = safePrevScore(m, 2, prevRoundNumForScore);
            rows.push([`第${idx + 1}台`, lnum, m.player1 ? m.player1.name : '', lscore, m.result || '', rscore, m.player2 ? m.player2.name : '', rnum]);
          }
        });
        return rows;
      }

      function exportAllSheetsToExcel() {
        try {
          try { if (typeof rehydrateRounds === 'function') rehydrateRounds(); } catch (e) { }

          const wb = XLSX.utils.book_new();
          const scoreboardData = buildScoreboardSheetData(currentRound || 0);
          const ws1 = XLSX.utils.aoa_to_sheet(scoreboardData);
          XLSX.utils.book_append_sheet(wb, ws1, '成績總表');

          for (let i = 1; i <= (totalRounds || 0); i++) {
            const data = buildPairingsSheetDataFor(i);
            const ws = XLSX.utils.aoa_to_sheet(data);
            const name = `第${i}輪`;
            const sheetName = name.length > 31 ? name.slice(0, 31) : name;
            XLSX.utils.book_append_sheet(wb, ws, sheetName);
          }

          const safeName = (tournamentName && tournamentName.trim()) ? tournamentName.trim() : 'tournament';
          const fileName = `${safeName}.xlsx`;

          XLSX.writeFile(wb, fileName);
          try { showToast && showToast('已匯出 Excel:' + fileName, 3000); } catch (e) { }
        } catch (err) {
          console.error('exportAllSheetsToExcel failed', err);
          alert('匯出失敗:' + (err && err.message ? err.message : err));
        }
      }

      function attachButton() {
        const btn = document.getElementById('exportAllExcelBtn');
        if (!btn) return;
        btn.addEventListener('click', function () {
          exportAllSheetsToExcel();
        });
      }

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(attachButton, 50);
      } else {
        document.addEventListener('DOMContentLoaded', attachButton);
      }
    })();

    function buildCertificateText() {
      const nameInput = document.getElementById('tournamentName');
      const dateInput = document.getElementById('tournamentDate');
      const rawName = nameInput && nameInput.value ? nameInput.value.trim() : (typeof tournamentName !== 'undefined' ? (tournamentName || '') : '');
      const tourDate = dateInput && dateInput.value ? dateInput.value : (typeof tournamentDate !== 'undefined' ? (tournamentDate || '') : '');
      const brokenName = rawName ? rawName.replace(/\s+/g, '\n') : '';
      let playerNames = [];
      const sbRows = Array.from(document.querySelectorAll('#scoreboard tbody tr'));
      if (sbRows && sbRows.length) {
        playerNames = sbRows.map(row => {
          const tds = row.querySelectorAll('td,th');
        }).filter(Boolean);
      }
      if ((!playerNames || playerNames.length === 0) && Array.isArray(players) && players.length) {
        playerNames = players.map(p => p && p.name ? String(p.name).trim() : '').filter(Boolean);
      }
      const lines = [];
      if (brokenName) lines.push(brokenName);
      if (tourDate) lines.push(tourDate);
      lines.push(...playerNames);
      return lines.join('\n');
    }

    async function copyCertificateToClipboard() {
      const text = buildCertificateText();
      if (!text || !text.trim()) {
        alert('找不到可複製的內容(請先設定比賽名稱/日子或確保成績總表有選手)');
        return;
      }
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(text);
          try { if (typeof showToast === 'function') showToast('已複製到剪貼簿', 2000); else alert('已複製到剪貼簿'); } catch (e) { alert('已複製到剪貼簿'); }
          return;
        }
      } catch (err) {
        console.warn('navigator.clipboard.writeText 失敗, 進入 fallback', err);
      }
      try {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.select();
        const ok = document.execCommand('copy');
        document.body.removeChild(ta);
        if (ok) {
          alert('已複製到剪貼簿(使用 fallback)');
          return;
        }
      } catch (e) {
        console.warn('execCommand fallback 失敗', e);
      }
      prompt('請手動複製以下文字(Ctrl/Cmd+C):', text);
    }

    document.addEventListener('DOMContentLoaded', function () {
      const copyBtn = document.getElementById('copyCertificateBtn');
      if (copyBtn) {
        copyBtn.addEventListener('click', copyCertificateToClipboard);
      } else {
        const spb = document.getElementById('screenshotPairingsBtn');
        if (spb && spb.parentNode) {
          const btn = document.createElement('button');
          btn.id = 'copyCertificateBtn';
          btn.textContent = '複製獎狀內容';
          spb.parentNode.insertBefore(btn, spb);
          btn.addEventListener('click', copyCertificateToClipboard);
        } else {
          console.warn('找不到 screenshotPairingsBtn,未自動加入 copyCertificateBtn');
        }
      }
    });

    function updateLayoutBasedOnWidth() {
      const playersSection = document.getElementById('playersSection');
      const body = document.body;
      const container = document.querySelector('.container') || document.body;
      const leftCol = document.querySelector('.left');
      const rightCol = document.getElementById('rightColumn');
      const scoreboardSection = document.getElementById('scoreboardSection');
      const roundSection = document.getElementById('roundSection');
      const vw = container.clientWidth || window.innerWidth;
      const playersVisible = playersSection && playersSection.classList.contains('open');
      body.classList.remove('layout-split', 'layout-single-column', 'layout-three-column', 'layout-split-with-players', 'layout-split-huge');
      function placeScoreboardTo(parent) {
        if (!scoreboardSection || !parent) return;
        if (scoreboardSection.parentElement !== parent) parent.appendChild(scoreboardSection);
      }
      const breakpoint = 1350;

      if (vw >= breakpoint) {
        placeScoreboardTo(rightCol);
        if (leftCol) {
          leftCol.style.flex = '0 0 50%';
          leftCol.style.width = '50%';
        }
        if (rightCol) {
          rightCol.style.flex = '0 0 50%';
          rightCol.style.width = '50%';
        }
        body.classList.add('layout-split');
      } else {
        placeScoreboardTo(leftCol);
        if (leftCol) {
          leftCol.style.flex = '1 1 auto';
          leftCol.style.width = '100%';
        }
        if (rightCol) {
          rightCol.style.flex = '';
          rightCol.style.width = '';
        }
        body.classList.add('layout-single-column');
      }
    }
    (function () {
      const scoreboardNameCellsSelector = '#scoreboard tbody tr td:nth-child(2)';
      const pairingsNameSelector =
        '#roundSection .playerName, #roundSection .player-name, ' +
        '#roundSection tbody tr td.playerName, #roundSection tbody tr td.player-name, ' +
        '#roundSection .match-player strong.player-name, #roundSection .match-player strong.playerName';
      const targetContainers = [];

      const scoreboardContainer = document.getElementById('scoreboard');
      if (scoreboardContainer) targetContainers.push(scoreboardContainer);
      const roundSection = document.getElementById('roundSection') || document.querySelector('#pairingsSection');
      if (roundSection) targetContainers.push(roundSection);
      function hideTargetsBeforeProcessing() {
        targetContainers.forEach(c => c.setAttribute('data-suppress-name-flash', '1'));
      }

      function showTargetsAfterProcessing() {
        targetContainers.forEach(c => c.removeAttribute('data-suppress-name-flash'));
      }

      function hasSmallLatin(el) {
        return !!(el.querySelector && el.querySelector('.small-latin'));
      }

      function wrapAsciiRunsInElement(el) {
        if (!el) return;
        if (hasSmallLatin(el)) return;

        const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
          acceptNode(node) {
            if (!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
            let p = node.parentNode;
            while (p) {
              if (p.classList && p.classList.contains('small-latin')) return NodeFilter.FILTER_REJECT;
              p = p.parentNode;
            }
            return NodeFilter.FILTER_ACCEPT;
          }
        }, false);

        const textNodes = [];
        while (walker.nextNode()) textNodes.push(walker.currentNode);

        const re = /[A-Za-z0-9\-\._\(\)\[\]]+/g;
        textNodes.forEach(textNode => {
          const text = textNode.nodeValue;
          let last = 0;
          const frag = document.createDocumentFragment();
          let m;
          while ((m = re.exec(text)) !== null) {
            const idx = m.index;
            if (idx > last) frag.appendChild(document.createTextNode(text.slice(last, idx)));
            const span = document.createElement('span');
            span.className = 'small-latin';
            span.textContent = m[0];
            frag.appendChild(span);
            last = idx + m[0].length;
          }
          if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
          if (frag.childNodes.length > 0 && !(frag.childNodes.length === 1 && frag.firstChild.nodeType === 3 && frag.firstChild.nodeValue === text)) {
            textNode.parentNode.replaceChild(frag, textNode);
          }
        });
      }

      function processSelectorsOnce() {
        const scoreCells = Array.from(document.querySelectorAll(scoreboardNameCellsSelector || ''));
        scoreCells.forEach(cell => wrapAsciiRunsInElement(cell));

        const pairingCells = Array.from(document.querySelectorAll(pairingsNameSelector || ''));
        pairingCells.forEach(cell => wrapAsciiRunsInElement(cell));
      }

      function observeTargets() {
        const observed = targetContainers.slice();
        if (!observed.length) return;
        const observer = new MutationObserver(muts => {
          let need = [];
          for (const mut of muts) {
            if (mut.addedNodes && mut.addedNodes.length) {
              mut.addedNodes.forEach(n => {
                if (n.nodeType === 1) {
                  const sNodes = Array.from(n.querySelectorAll ? n.querySelectorAll(scoreboardNameCellsSelector) : []);
                  const pNodes = Array.from(n.querySelectorAll ? n.querySelectorAll(pairingsNameSelector) : []);
                  need.push(...sNodes, ...pNodes);
                  if (n.matches && n.matches(scoreboardNameCellsSelector)) need.push(n);
                  if (n.matches && n.matches(pairingsNameSelector)) need.push(n);
                } else if (n.nodeType === 3) {
                  if (n.parentNode && (n.parentNode.matches && (n.parentNode.matches(scoreboardNameCellsSelector) || n.parentNode.matches(pairingsNameSelector)))) {
                    need.push(n.parentNode);
                  }
                }
              });
            }
            if (mut.type === 'characterData' && mut.target && mut.target.parentNode) {
              const p = mut.target.parentNode;
              if (p.matches && (p.matches(scoreboardNameCellsSelector) || p.matches(pairingsNameSelector))) need.push(p);
            }
          }
          if (need.length) {
            const uniq = Array.from(new Set(need));
            uniq.forEach(node => wrapAsciiRunsInElement(node));
          }
        });

        observed.forEach(root => observer.observe(root, { childList: true, subtree: true, characterData: true }));
      }

      function init() {
        targetContainers.forEach(c => {
          c.style.visibility = 'hidden';
        });

        processSelectorsOnce();

        targetContainers.forEach(c => {
          c.style.visibility = '';
        });

        observeTargets();
      }

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(init, 10);
      } else {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      }
    })();

    window.addEventListener('resize', updateLayoutBasedOnWidth);

  </script>

  <script>
    (function () {
      let pairingWindow = null, scoreboardWindow = null, pairingObserver = null, scoreboardObserver = null;


      function cleanNodeForClone(node) {
        const clone = node.cloneNode(true);

        try { clone.querySelectorAll('script').forEach(s => s.remove()); } catch (e) { }

        try { clone.querySelectorAll('[contenteditable]').forEach(n => n.removeAttribute('contenteditable')); } catch (e) { }
        try {
          const rows = clone.querySelectorAll('.match-row');
          Array.from(rows).forEach(row => {
            try {
              const selBtn = row.querySelector('.result-btn.selected, button.result-btn.selected, .result-choice .selected, input[type="radio"]:checked, [data-selected="true"]');
              const submittedText = selBtn ? (selBtn.textContent || selBtn.value || '').trim() : '';
              const controls = row.querySelectorAll('button,input,select,textarea,form');
              Array.from(controls).forEach(el => {
                try {
                  const isSelected = el === selBtn || (el.classList && el.classList.contains('selected'));
                  const span = document.createElement('span');
                  span.className = 'cas-preserve-control';
                  let txt = '';
                  if (el.tagName.toLowerCase() === 'input') txt = el.value || el.placeholder || '';
                  else txt = el.textContent || el.value || '';
                  txt = String(txt || '').trim();
                  if (/^(2:0|1:1|0:2|2-0|1-1|0-2)$/.test(txt)) {
                    span.textContent = '';
                    span.style.display = 'none';
                  } else {
                    span.textContent = txt;
                  }
                  if (el.parentNode) el.parentNode.replaceChild(span, el);
                } catch (e) { }
              });
              row.querySelectorAll && row.querySelectorAll('a[href]').forEach(a => a.removeAttribute('href'));
              if (submittedText) {
                let resultCell = row.querySelector('.match-result');
                if (!resultCell) {
                  const children = Array.from(row.children || []);
                  if (children.length >= 3) resultCell = children[Math.floor(children.length / 2)];
                }
                if (resultCell) {
                  resultCell.innerHTML = '';
                  const badge = document.createElement('div');
                  badge.className = 'submitted-badge';
                  badge.textContent = submittedText;
                  resultCell.appendChild(badge);
                }
              } else {
                let resultCell = row.querySelector('.match-result');
                if (resultCell) {
                  Array.from(resultCell.querySelectorAll('.cas-preserve-control')).forEach(sp => {
                    const v = (sp.textContent || '').trim();
                    if (/^(2:0|1:1|0:2|2-0|1-1|0-2)$/.test(v)) {
                      sp.style.display = 'none';
                      sp.textContent = '';
                    }
                  });
                }
              }
            } catch (e) { }
          });
        } catch (e) { }
        try {
          ['submitRoundBtn', 'nextRoundBtn', 'removeRoundBtn'].forEach(id => {
            const el = clone.querySelector('#' + id);
            if (el && el.parentNode) el.parentNode.removeChild(el);
          });

          const textsToRemove = ['返回上一步', '提交本輪結果', '下一輪'];
          clone.querySelectorAll('button, a, input[type="button"], input[type="submit"]').forEach(el => {
            try {
              const t = (el.textContent || el.value || '').trim();
              if (textsToRemove.includes(t)) {
                if (el.parentNode) el.parentNode.removeChild(el);
              }
            } catch (e) { }
          });
          try {
            const style = document.createElement('style');
            style.textContent = `
      #submitRoundBtn, #nextRoundBtn, #removeRoundBtn,
      .hide-in-readonly { display: none !important; }
    `;
            const head = clone.querySelector('head') || clone;
            head.appendChild(style);
          } catch (e) { }
          try {
            const style2 = document.createElement('style');
            style2.textContent = `
    #scoreboard th:nth-child(3), #scoreboard td:nth-child(3),
    #scoreboard th:nth-child(6), #scoreboard td:nth-child(6),
    #scoreboard th:nth-child(8), #scoreboard td:nth-child(8),
    #scoreboard th:nth-child(9), #scoreboard td:nth-child(9) {
      display: none !important;
    }
  `;
            (clone.querySelector('head') || clone).appendChild(style2);
          } catch (e) { console.warn('append hide-columns style failed', e); }

        } catch (e) {
        }
        try {
          clone.querySelectorAll('.history-row, .history-box, td.opponent-history').forEach(el => el.remove());
          const compactStyle = document.createElement('style');
          compactStyle.type = 'text/css';
          compactStyle.appendChild(document.createTextNode(`
    .history-row, .history-box, td.opponent-history { display: none !important; }
    #scoreboard, #scoreboard tbody { border-collapse: collapse !important; }
    #scoreboard th, #scoreboard td {
      padding: 2px 6px !important;
      line-height: 1 !important;
      font-size: 18px !important; 
      white-space: nowrap !important;
    }
    #scoreboard tbody tr { height: 20px !important; }
    #scoreboard tbody tr:not(.history-row) td { height: 20px !important; }
    .history-item { margin: 0 !important; padding: 0 !important; font-size: 18px !important; line-height: 1 !important; }
  `));
          (clone.querySelector('head') || clone).appendChild(compactStyle);
        } catch (e) {
          console.warn('compact style / remove history failed', e);
        }
        try {
          clone.querySelectorAll('.history-row, .history-box, td.opponent-history').forEach(el => el.remove());
          const override = document.createElement('style');
          override.type = 'text/css';
          override.appendChild(document.createTextNode(`
    #scoreboard tbody tr:nth-child(-n+16) td:nth-child(1),
    #scoreboard tbody tr:nth-child(-n+16) td:nth-child(2) { background: none !important; }

    #scoreboard tbody tr.top8 td:nth-child(1),
    #scoreboard tbody tr.top8 td:nth-child(2) { background-color: #fffd95 !important; }
  `));
          (clone.querySelector('head') || clone).appendChild(override);
          const tbody = clone.querySelector('#scoreboard tbody');
          if (tbody) {
            tbody.querySelectorAll('tr.top8').forEach(t => t.classList.remove('top8'));
            const rows = Array.from(tbody.querySelectorAll('tr')).filter(tr => {
              if (tr.classList.contains('history-row') || tr.classList.contains('history-box')) return false;
              const cs = window.getComputedStyle(tr);
              return cs.display !== 'none' && cs.visibility !== 'hidden';
            });
            rows.slice(0, 8).forEach(tr => tr.classList.add('top8'));
            try {
              (function applyScoreBgToClone() {
                try {
                  const roundToCheck = (typeof viewRound !== 'undefined' && viewRound) ? viewRound : (typeof currentRound !== 'undefined' ? currentRound : 0);
                  const tbody2 = clone.querySelector('#scoreboard tbody');
                  if (!tbody2 || !Array.isArray(players)) return;
                  const roundObj = (Array.isArray(rounds) && rounds[roundToCheck - 1]) ? rounds[roundToCheck - 1] : null;

                  Array.from(tbody2.querySelectorAll('tr')).forEach(tr => {
                    try {
                      const cells = tr.querySelectorAll('td,th');
                      if (!cells || cells.length < 4) return;
                      const nameText = (cells[1].textContent || '').trim();
                      if (!nameText) return;
                      const player = players.find(p => p && String(p.name || '').trim() === nameText);
                      if (!player) return;
                      let hasResultForRound = Array.isArray(player.roundResults) &&
                        player.roundResults.some(r => Number(r.round) === Number(roundToCheck) && r.outcome && r.outcome !== '待定');

                      if (!hasResultForRound && roundObj && Array.isArray(roundObj.matches)) {
                        hasResultForRound = roundObj.matches.some(m => {
                          if (!m) return false;
                          const p1id = m.player1 && (m.player1.id || null);
                          const p2id = m.player2 && (m.player2.id || null);
                          const pid = player.id;
                          const involved = (p1id === pid) || (p2id === pid);
                          if (!involved) return false;
                          if (typeof m.result !== 'undefined' && m.result !== null) {
                            const rv = String(m.result || '').trim();
                            return rv.length > 0 && rv !== '待定';
                          }
                          return false;
                        });
                      }
                      if ((hasResultForRound && Number(roundToCheck) > 1) ||
                        (Number(cells[3].textContent.trim()) > 0 && Number(roundToCheck) === 1)) {
                        cells[3].style.backgroundColor = '#ffed95';
                      } else {
                        cells[3].style.backgroundColor = 'transparent';
                      }
                    } catch (e) { }
                  });
                } catch (err) {
                  console.warn('applyScoreBgToClone error', err);
                }
              })();
            } catch (e) { console.warn('apply score bg failed', e); }
          }
        } catch (e) {
          console.warn('fix preview top8 failed', e);
        }
        try {
          clone.style.margin = '12px';
          const outerWrapper = document.createElement('div');
          outerWrapper.style.background = '#99FFFF';//關鍵位*
          outerWrapper.style.padding = '12px';
          outerWrapper.style.boxSizing = 'border-box';
          outerWrapper.style.minHeight = '100%';
          outerWrapper.style.width = '100%';
          outerWrapper.style.height = '1070px';
          outerWrapper.appendChild(clone);
          return outerWrapper;
        } catch (err) {
          console.warn('包裝 outerWrapper 失敗，回傳原 clone', err);
          return clone;
        }
      }

      function getHeadSnapshot() {
        const head = document.head;
        const allowed = [];
        for (const node of head.children) {
          const tag = node.tagName.toLowerCase();
          if (tag === 'link' && (node.rel === 'stylesheet' || node.rel === 'icon')) allowed.push(node.outerHTML);
          else if (tag === 'style' || tag === 'meta' || tag === 'title' || tag === 'base') allowed.push(node.outerHTML);
        }
        allowed.push('<style>button,input,select,textarea,form,a{pointer-events:none!important;cursor:default!important;} .cas-preserve-control{white-space:pre-wrap;}</style>');
        return allowed.join('\n');
      }

      function buildDoc(headHtml, contentHtml) {
        return '<!doctype html><html><head>' + headHtml + '</head><body style="margin:0;">' + contentHtml + '</body></html>';
      }

      function openSyncWindow(type) {
        const id = type === 'pairings' ? 'pairings_window' : 'scoreboard_window';
        const width = type === 'pairings' ? 634 : 634;
        const height = type === 'pairings' ? 1080 : 1080;
        const features = `width=${width},height=${height},resizable=yes,scrollbars=yes,menubar=no,toolbar=no,location=no`;
        const w = window.open('', '_blank', features);

        if (!w) {
          alert('無法開啟新視窗：請允許彈跳視窗或關閉瀏覽器的彈跳視窗攔截器。');
          return null;
        }
        if (type === 'pairings') pairingWindow = w;
        else scoreboardWindow = w;
        try { w.focus(); } catch (e) { }
        return w;
      }

      function sync(type) {
        try {
          const src = type === 'pairings' ? (document.getElementById('roundSection') || document.getElementById('roundContainer') || document.querySelector('[data-pairings]')) :
            (document.getElementById('scoreboardSection') || document.getElementById('scoreboard') || document.querySelector('[data-scoreboard]'));
          const targetWindow = type === 'pairings' ? pairingWindow : scoreboardWindow;
          if (!src || !targetWindow || targetWindow.closed) return;

          const clone = cleanNodeForClone(src);
          const containerHtml = clone.outerHTML;
          const headSnap = getHeadSnapshot();
          const docHtml = buildDoc(headSnap, containerHtml);

          try {
            targetWindow.document.open();
            targetWindow.document.write(docHtml);
            targetWindow.document.close();
          } catch (writeErr) {
            console.warn('寫入目標視窗失敗', writeErr);
            try {
              targetWindow.location = 'about:blank';
              targetWindow.document.open();
              targetWindow.document.write(docHtml);
              targetWindow.document.close();
            } catch (e2) {
              console.warn('fallback 寫入仍失敗', e2);
            }
          }

          try {
            const existingTitle = (targetWindow.document && typeof targetWindow.document.title === 'string') ? targetWindow.document.title : '';
            const suffix = (type === 'pairings') ? ' 對陣表' : ' 成績總表';
            if (existingTitle && existingTitle.trim()) {
              if (!existingTitle.includes(suffix.trim())) {
                targetWindow.document.title = existingTitle + suffix;
              }
            } else {
              const hostTitle = (document && document.title && document.title.trim()) ? document.title.trim() : '';
              if (hostTitle) {
                const newTitle = hostTitle + suffix;
                try { targetWindow.document.title = newTitle; } catch (e) { }
              }
            }
          } catch (e) {
            console.warn('設定視窗標題後綴失敗', e);
          }
        } catch (e) {
          console.warn('sync error', e);
        }
      }

      function startObserving(type) {
        const src = type === 'pairings' ? (document.getElementById('roundSection') || document.getElementById('roundContainer') || document.querySelector('[data-pairings]')) :
          (document.getElementById('scoreboardSection') || document.getElementById('scoreboard') || document.querySelector('[data-scoreboard]'));
        if (!src) return;
        const observer = new MutationObserver(() => sync(type));
        observer.observe(src, { childList: true, subtree: true, attributes: true, characterData: true });
        return observer;
      }

      window.openPairingsReadOnlyWindow = function () {
        pairingWindow = openSyncWindow('pairings');
        if (!pairingWindow) return;
        sync('pairings');
        if (pairingObserver) pairingObserver.disconnect();
        pairingObserver = startObserving('pairings');
        if (pairingWindow) pairingWindow.onbeforeunload = () => { if (pairingObserver) { pairingObserver.disconnect(); pairingObserver = null; } pairingWindow = null; };
      };

      window.openScoreboardReadOnlyWindow = function () {
        scoreboardWindow = openSyncWindow('scoreboard');
        if (!scoreboardWindow) return;
        sync('scoreboard');
        if (scoreboardObserver) scoreboardObserver.disconnect();
        scoreboardObserver = startObserving('scoreboard');
        if (scoreboardWindow) scoreboardWindow.onbeforeunload = () => { if (scoreboardObserver) { scoreboardObserver.disconnect(); scoreboardObserver = null; } scoreboardWindow = null; };
      };

      document.addEventListener('contextmenu', function (e) {
        try {
          const round = document.getElementById('roundSection') || document.getElementById('roundContainer') || document.querySelector('[data-pairings]');
          const sb = document.getElementById('scoreboardSection') || document.getElementById('scoreboard') || document.querySelector('[data-scoreboard]');
          if (round && round.contains(e.target)) { e.preventDefault(); window.openPairingsReadOnlyWindow(); return; }
          if (sb && sb.contains(e.target)) { e.preventDefault(); window.openScoreboardReadOnlyWindow(); return; }
        } catch (err) { }
      }, false);
    })();
  </script>

  <script>
    (function () {
      function escapeHtml(s) {
        if (!s) return '';
        return String(s).replace(/[&<>"']/g, function (m) {
          return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m];
        });
      }
      function buildHeaderCardHtml({ name, date, rounds, timeText }) {
        const safeName = escapeHtml(name || '');
        const safeDate = escapeHtml(date || '');
        const safeRounds = escapeHtml(String(rounds || ''));
        const safeTimeText = escapeHtml(timeText || '');

        // 做法 A：把最後一次空白換成 <br>（先 escape，再插入 HTML）
        // 注意：使用 escapeHtml(someRawName) 以避免 XSS，然後 replace 最後一段空白為 <br>
        const rawName = name || '未設定比賽名稱';
        const titleHtml = escapeHtml(rawName).replace(/\s+([^\s]+)$/, '<br>$1');

        return `
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>${safeName || '賽事資訊'}</title>
  <style>
    html,body{height:100%;margin:0;padding:0;font-family: "Noto Sans TC", "Segoe UI", Roboto, sans-serif;background:linear-gradient(135deg,#ff6b6b,#ffd166);color:#fff;}
    /* 這個 container 寬度是 calc(100% - 400px)，也就是右邊預留 400px */
    .container{
      height:100%;
      width: calc(100% - 400px);
      display:flex;
      align-items:center;
      justify-content:center;
      margin:0; /* 保持左對齊，右邊自然留 400px */
    }
    .card{
      text-align:center;
      padding:20px 28px;
      border-radius:18px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.12);
      background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.02));
      color:#fff;
      max-width:calc(100% - 120px);
      width:100%;
    }
    .title {
      font-size: clamp(18px, 5vw, 41px);
      font-weight: 800;
      letter-spacing: 0.6px;
      margin:0 0 8px 0;
      text-shadow: 0 6px 18px rgba(0,0,0,0.35);
    }
    .meta {
      font-size: clamp(13px, 3vw, 20px);
      font-weight:700;
      opacity:0.98;
      background: rgba(0,0,0,0.12);
      display:inline-block;
      padding:8px 12px;
      border-radius:999px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.12);
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card" id="cas_header_card">
      <div class="title">${titleHtml}</div>
      <div class="meta">${safeDate}  ｜  共 ${safeRounds} 輪  ｜  ${safeTimeText}</div>
    </div>
  </div>

  <script>
    function tryClose() { try { window.close(); } catch(e){} }
    document.addEventListener('click', tryClose);
    document.addEventListener('keydown', function(e){ if (e.key === 'Escape') tryClose(); });
  <\/script>
</body>
</html>
`;
      }

      function attachHeaderContextMenu() {
        const headerEl = document.getElementById('competitionHeader') || document.querySelector('.competition-info') || document.querySelector('.topbar') || document.querySelector('header');
        if (!headerEl) {
          console.warn('找不到頂端欄位 (#competitionHeader / .competition-info / .topbar / header)，無法綁定右鍵預覽賽事卡。');
          return;
        }

        headerEl.addEventListener('contextmenu', function (e) {
          e.preventDefault();
          e.stopPropagation();
          const name = (typeof tournamentName !== 'undefined' && tournamentName) ? tournamentName :
            (document.getElementById('tournamentName') ? document.getElementById('tournamentName').value : '') ||
            (document.querySelector('.tournament-title') ? document.querySelector('.tournament-title').textContent : '') ||
            (document.querySelector('#title') ? document.querySelector('#title').textContent : '') ||
            document.title;

          const date = (typeof tournamentDate !== 'undefined' && tournamentDate) ? tournamentDate :
            (document.getElementById('tournamentDate') ? document.getElementById('tournamentDate').value : '') ||
            (document.querySelector('.tournament-date') ? document.querySelector('.tournament-date').textContent : '');

          const rounds = (typeof totalRounds !== 'undefined' && totalRounds !== null && totalRounds !== undefined) ? totalRounds :
            (document.querySelectorAll('.round-btn.selected-round').length ? document.querySelector('.round-btn.selected-round').dataset.round : '') ||
            (document.querySelector('.rounds-count') ? document.querySelector('.rounds-count').textContent : '');

          const timeSelect = document.getElementById('timeControl') || document.querySelector('select.timeControl');
          const timeText = timeSelect ? (timeSelect.options[timeSelect.selectedIndex] ? timeSelect.options[timeSelect.selectedIndex].text : '') : (document.querySelector('.time-text') ? document.querySelector('.time-text').textContent : '');

          const html = buildHeaderCardHtml({ name, date, rounds, timeText });

          const features = 'width=1286,height=245,resizable=yes,scrollbars=no,menubar=no,toolbar=no,location=no';
          const w = window.open('', '_blank', features);
          if (w && w.document) {
            try {
              w.document.open();
              w.document.write(html);
              w.document.close();
              try { w.focus(); } catch (e) { }
              return;
            } catch (err) {
              console.warn('open popup failed, fallback to modal', err);
            }
          }

          showInlineHeaderModal({ name, date, rounds, timeText });
        }, { passive: false });
      }

      function showInlineHeaderModal({ name, date, rounds, timeText }) {
        const existing = document.getElementById('cas_header_preview_modal');
        if (existing) existing.remove();

        const modal = document.createElement('div');
        modal.id = 'cas_header_preview_modal';
        modal.style.position = 'fixed';
        modal.style.left = '50%';
        modal.style.top = '8%';
        modal.style.transform = 'translateX(-50%)';
        modal.style.zIndex = '2147483647';
        modal.style.width = 'min(92%,840px)';
        modal.style.boxSizing = 'border-box';
        modal.style.padding = '10px';
        modal.style.borderRadius = '14px';
        modal.style.boxShadow = '0 18px 40px rgba(0,0,0,0.28)';
        modal.style.backdropFilter = 'blur(6px)';
        modal.style.background = 'linear-gradient(90deg, rgba(255,111,97,0.95), rgba(247,180,103,1))';//關鍵位*
        modal.style.color = '#ffffff';
        modal.style.textAlign = 'center';

        const title = document.createElement('div');
        title.textContent = name || '未設定比賽名稱';
        title.style.fontSize = 'clamp(22px, 6vw, 56px)';
        title.style.fontWeight = '800';
        title.style.margin = '6px 0';
        title.style.textShadow = '0 6px 18px rgba(0,0,0,0.26)';
        modal.appendChild(title);

        const meta = document.createElement('div');
        meta.textContent = `${date || ''}  ｜  共 ${rounds || ''} 輪  ｜  ${timeText || ''}`;
        meta.style.display = 'inline-block';
        meta.style.padding = '8px 12px';
        meta.style.fontWeight = '700';
        meta.style.borderRadius = '999px';
        meta.style.background = 'rgba(255,255,255,0.08)';
        meta.style.marginBottom = '6px';
        modal.appendChild(meta);

        const closeBtn = document.createElement('button');
        closeBtn.textContent = '關閉';
        closeBtn.style.marginLeft = '12px';
        closeBtn.style.padding = '6px 10px';
        closeBtn.style.border = 'none';
        closeBtn.style.borderRadius = '8px';
        closeBtn.style.cursor = 'pointer';
        closeBtn.onclick = () => modal.remove();
        modal.appendChild(closeBtn);

        document.body.appendChild(modal);

        setTimeout(() => {
          try { if (modal && modal.parentNode) modal.parentNode.removeChild(modal); } catch (e) { }
        }, 8000);
      }

      if (document.readyState === 'complete' || document.readyState === 'interactive') {
        setTimeout(attachHeaderContextMenu, 40);
      } else {
        document.addEventListener('DOMContentLoaded', attachHeaderContextMenu);
      }
    })();
  </script>
</body>

</html>
